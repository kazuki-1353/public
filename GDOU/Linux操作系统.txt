第 七 章 Linux 系统安全
Linux 操作系统以安全性和稳定性著称，许多大型门户网站都以 Linux 作为服务器操
作系统。然而随着黑客攻击技术的发展，系统安全防范工作仍然需要系统管理员的高度重
视。在本章，首先介绍了几种常见的攻击类型以及 Linux 系统中帮助管理员发现攻击的重
要工具——系统日志的管理，然后阐述了 Linux 系统的账号安全、网络安全等，并讲述如
何使用 snort 进行入侵检测。
7.1 常见的攻击类型
常见的攻击方式包括端口扫描、嗅探、种植木马、传播病毒等。
1. 端口扫描
在网络技术中，端口（Port）通常有两种含义，一是物理意义上的端口，即调制解调
器、网络集线器、交换机、路由器中用于连接其他网络设备的接口，如 RJ-45 端口、SC 端
口等；二是逻辑意义上的端口，即指 TCP/IP 协议中的端口，用于承载特定的网络服务，其
编号的范围为 0～65535，例如，用于承载 Web 服务的是 80 端口，用于承载 FTP 服务的是
21 端口和 20 端口等。在网络技术中，每个端口承载的网络服务是特定的，因此可以根据
端口的开放情况来判断当前系统中开启的服务。
扫描器就是通过依次试探远程主机 TCP 端口，获取目标主机的响应，并记录目标主机
的响应。根据这些响应的信息可以搜集到很多关于目标主机的有用信息，包括该主机是否
支持匿名登录以及提供某种服务的软件包的版本等。这些信息可以直接或间接地帮助攻击
者了解目标主机可能存在的安全问题。
端口扫描器并不是一个直接攻击网络漏洞的程序，但是它能够帮助攻击者发现目标主
机的某些内在安全问题。目前常用的端口扫描技术有 TCP connect 扫描、TCP SYN 扫描、
TCP FIN 扫描、IP 段扫描、TCP 反向 ident 扫描以及 TCP 返回攻击等。通常扫描器应该具
备如下的 3 项功能：
发现一个主机或网络的能力。
发现远程主机后，有获取该主机正在运行的服务的能力。
通过测试远程主机上正在运行的服务，发现漏洞的能力。
2. 嗅探
嗅探技术是一种重要的网络安全攻防技术，攻击者可以通过嗅探技术以非常隐蔽的方
式攫取网络中的大量敏感信息，与主动扫描相比，嗅探更加难以被发觉，也更加容易操作
和实现。对于网络管理员来说，借助嗅探技术可以对网络活动进行实时监控，发现网络中
的各种攻击行为。
嗅探操作的成功实施是因为以太网的共享式特性决定的。由于以太网是基于广播方式
传输数据的，所有的物理信号都会被传送到每一个网络主机结点，而且以太网中的主机网
卡允许设置成混杂接收模式，在这种模式下，无论监听到的数据帧的目的地址如何，网卡
都可以予以接收。更重要的是，在 TCP/IP 协议栈中网络信息的传递大多是以明文传输的，
这些信息中往往包含了大量的敏感信息，比如邮箱、FTP 或 telnet 的账号和口令等，因此
使用嗅探的方法可以获取这些敏感信息。
嗅探器最初是作为网络管理员检测网络通信的工具出现的，它既可以是软件的，也可
以是硬件设备。软件嗅探器使用方便，可以针对不同的操作系统使用不同的软件嗅探器，
而且很多软件嗅探器都是免费的。常用的嗅探器有 Tcpdump/Windump、Sniffit、Ettercap
和 Snarp 等。
处于网络中的主机，如果发现网络出现了数据包丢失率很高或网络带宽长期被网络中
的某台主机占用，就应该怀疑网络中是否存在嗅探器。
3. 木马
木马又称特洛伊木马，是一种恶意计算机程序，长期驻留在目标计算机中，可以随系
统启动并且秘密开放一个甚至多个数据传输通道的远程控制程序。木马程序一般由客户端
(Client)和服务器端(Server)两部分组成，客户端也称为控制端，一般位于入侵者计算机
中，服务器端则一般位于用户计算机中。木马本身不带伤害性，也没有感染能力，所以木
马不是病毒。
木马通常具有隐蔽性和非授权性的特点。所谓隐蔽性是指木马的设计者为了防止木马
被发现，会采用多种手段隐藏木马，这样服务端计算机即使发现感染了木马，也不能确定
其具体位置。所谓非授权性是指一旦客户端与服务端连接后，客户端将享有服务端的大部
分操作权限，包括修改文件、修改注册表、控制鼠标、键盘等，这些权力并不是服务端赋
予的，而是通过木马程序窃取的。
入侵者一般使用木马来监视监视被入侵者或盗取被入侵者的密码、敏感数据等。
4. 病毒
虽然 Linux 系统的病毒并不像 Windows 系统那样数量繁多，但是威胁 Linux 平台的病
毒同样存在，如Klez、Lion.worm、Morris.worm、Slapper、Scalper、Linux.Svat 和 BoxPoison
病毒等。Linux 下的病毒可以如下分类：
（1）蠕虫（worm）病毒
1988 年 Morris 蠕虫爆发后，Eugene H. Spafford 给出了蠕虫的定义：“计算机蠕虫
可以独立运行，并能把自身的一个包含所有功能的版本传播到另外的计算机上”。和其他
种类的病毒相比，在 Linux 平台下最为猖獗的就是蠕虫病毒，如利用系统漏洞进行传播的
ramen、lion、Slapper 等，都曾给 Linux 系统用户造成了巨大的损失。随着 Linux 系统应
用越广泛，蠕虫的传播程度和破坏能力也会随之增加。
（2）可执行文件型病毒
可执行文件型病毒是指能够感染可执行文件的病毒，如 Lindose。这种病毒大部分都
只是企图以感染其他主机程序的方式进行自我复制。
（3）脚本病毒
目前出现比较多的是使用 shell 脚本语言编写的病毒。此类病毒编写较为简单，但是
破坏力同样惊人。而一个十数行的 shell 脚本就可以在短时间内遍历整个硬盘中的所有脚
本文件，并进行感染。且此类病毒还具有编写简单的特点。
（4）后门程序
后门程序一般是指那些绕过安全性控制而获取程序或系统访问权的程序。在广义的病
毒定义概念中，后门也已经纳入了病毒的范畴。从增加系统超级用户账号的简单后门，到
利用系统服务加载，共享库文件注册，rootkit 工具包，甚至装载内核模块（LKM），Linux
平台下的后门技术发展非常成熟，其隐蔽性强，难以清除。
7.2 Linux 日志管理
在任何操作系统中，日志系统对于系统安全来说都是非常重要的，它记录了系统每天
发生的各种各样的事件，包括哪些用户曾经或正在使用系统，可以通过日志来检查系统和
应用程序发生错误的原因。日志还能在系统受到黑客攻击后，记录下攻击者留下的痕迹，
通过这些痕迹，系统管理员可以发现黑客攻击的手段及特点，从而能够进行相应的处理，
为抵御下一次攻击做好准备。日志主要的功能有审计和监测，另外，利用日志还可以实时
监测系统状态，监测和追踪侵入者等。
7.2.1 Linux 日志系统简介
在 Linux 系统中利用日志可以审计和检测系统出现的错误，侦查和追踪入侵，并协助
系统进行恢复和排除故障。在 RedHat Linux 9 系统中，日志功能通常是由 syslog（对应
syslogd 守护进程）和 klog（对应 klogd 守护进程）日志系统来完成，syslog 记录常规系
统日志，而 klog 是针对内核活动的日志。
Linux 日志是按照类别保存在日志文件中的，一般保存在/var/log 目录下，绝大部分
只有系统管理员才能够查看。
如表 7.1 列出了/var/log 目录下的日志文件及其功能，其中“*”表示通配符。
表 7.1 /var/log 目录下的日志文件及其功能
日志文件 功能说明
cups 与打印服务相关的日志文件目录
gdm 存放 GNOME 启动日志文件目录
httpd 存放 Web 服务器日志文件的目录
news 存放网络新闻组服务相关的日志文件目录
squid 存放 squid 代理服务日志文件的目录
secure* 与安全连接相关的日志文件
scrollkeeper.log 用于GUI中文档的日志文件/var/log目录下的日志文
件及其功能
boot.log* 记录了与启动和停止守护进程相关的日志
messages* 记录系统的一般性日志
rpmpkgs 记录当前已安装的 RPM 软件包
lastlog 记录最近登录的系统用户
dmesg 记录了与系统启动相关的引导信息
wtmp 记录用户登录系统的状况
cron* 记录 crond 进程的日志文件
这些日志文件可以分为 3 类：
（1）连接时间日志
由多个程序执行，把记录写入到/var/log/wtmp 和/var/run/utmp 中，login 等程序更
新 wtmp 和 utmp 文件，使系统管理员能够跟踪谁在何时登录了到系统。
（2）进程统计
由系统内核执行。当一个进程终止时，为每个进程往进程统计文件（pacct 或 acct，
分别位于/usr/adm/pactt 和/usr/lib/acct/startup）中写一个纪录。进程统计的目的是
为系统中的基本服务提供命令使用统计。
（3）错误日志
由 syslogd（8）守护进程执行，各种系统守护进程、用户程序和内核通过 syslogd（8）
守护进程向文件/var/log/messages 报告值得注意的事件。
7.2.2 配置系统日志
几乎所有的类 UNIX 系统（如 Linux）系统都采用 syslog 进行系统日志的管理与配置。
任何程序可以通过 syslog 记录事件，并且可以将记录的系统事件写入到一个文件或设备，
或给用户发送一个邮件。
syslog 有两个重要的文件，一个是守护进程/sbin/syslogd，另一个是 syslogd 的配
置文件/etc/ /syslog.conf。通常多数的 syslog 信息被写到/var/log 目录下的日志文件
message.*中。一个典型的 syslog.conf 记录包括生成日志的程序名称、日志的设备名、日
志的优先等级以及一段文本信息。
1. 启动 g syslog 日志进程
启动 syslog 日志守护进程 syslogd 的命令格式如下：
/sbin/syslogd [选项]
该命令常用的参数及含义如表 7.2 所示。
表 7.2 syslogd 命令参数及含义
参数 含义
-a socket 添加日志监听的用户定义的套接口
-d 使用调试模式
-f conf_file 指定 syslogd 的配置文件
-h 记录远程主机返回的日志
-l hostlist 使用指定的简单主机名记录日志的主机名域
-p socket 使用指定的套接口启动 syslogd 进程
-r 接收并记录网络日志
重启 syslogd 日志守护进程，可以在终端提示符下输入如下的命令：
[root@localhost ~]# service syslogd restart 或
[root@localhost ~]# kill -HUP `cat /var/run/syslogd.pid`
说明：在该命令中，/var/run/syslogd.pid 文件存放了当前 syslogd 守护进程的 pid，
整个命令的执行步骤是，先使用 cat /var/run/syslogd.pid 获取当前系统的 syslogd 守护
进程的 pid，然后使用 kill 命令传递-HUP 信号给该 pid 指定的进程，对其进行重启操作。
d 2. syslogd 的主配置文件
系统日志 syslog 的主配置文件是/etc/syslog.conf。syslog 记录的内容及其记录存
放的日志文件由该文件指定，可以通过修改 syslog.conf 文件的方法来配置 syslogd。该
文件的基本语法格式如下：
设备(facility).优先级(priority) 动作
（1）日志设备 facility
日志设备 facility 表示日志消息的来源，指明了发出消息的设备或程序，主要设备及
说明如表 7.3 所示。
表 7.3 syslog 常用的日志设备及说明
设备 说明
kern 内核日志
uucp uucp 系统日志
user 用户程序日志
news 新闻组服务日志
mail 邮件系统日志
daemon 系统守护进程日志
syslog syslog 守护进程日志
auth 安全管理日志
lpr 打印服务日志
cron cron 守护进程日志
authpriv 私有授权系统日志
ftp ftp 守护进程日志
local0~local7 本地日志
（2）优先级 priority
日志优先级 priority 表明日志消息的紧急程度。如果在 syslog.conf 文件中的一行出
现多对“设备.优先级”，各项之间使用分号隔开。syslog 日志系统中常用的日志优先级
如表 7.4 所示，其中紧急程度由上到下逐级递减。
表 7.4 syslog 常用的日志优先级
日志优先级 说明
emerge 发生严重事件，并可能导致系统崩溃
alert 严重错误，将导致程序关闭，并可能影响其他程序
crit 错误消息，可能导致程序关闭
err 程序中存在错误
warning 程序中存在潜在问题的警告
notice 程序运行中出现了不正常的现象，需要检查
info 关于程序当前状态的报告信息
debug 编程人员或测试人员使用的调试信息
其中紧急程度遵循向上匹配的原则。例如，“err”优先级表示所有高于或等于 err 等
级的日志消息都将被处理，即所处理的日志消息包括“err”、“crit”、“alert”和“emerge”
等级的消息。如果只希望精确匹配某个确定的紧急程序，而不使用向上匹配原则，则需要
使用等号进行设定。例如，“kern.=alert”表示只对内核产生的 alert 日志信息进行处理。
在 syslog.conf 文件的配置行中，也支持通配符“*”和“none”，其中“*”表示匹
配全部，“none”表示全部忽略。例如，记录守护进程产生的所有日志消息可以使用
“daemon.*”，而忽略内核产生的所有日志消息则可以使用“kern.none”。
（5）动作
syslog.conf 文件配置行中的动作，用于设定 syslogd 如何处理对应的日志消息。处
理的办法，可以设定将日志信息写入文件或显示到终端设备上，或者通过邮件直接发送给
指定的用户，或者发送到另一台远程主机的 syslog 系统。
syslogd 可使用的动作及说明如表 7.5 所示。
表 7.5 syslogd 常用的动作及说明
动作 说明
@host_name 将日志消息转发到 host_name 指定的远程主机的 syslog 程序
@ip_addr 将日志消息转发到 ip_addr 指定的远程主机的 syslog 程序
* 将日志消息转发到系统中所有用户的终端
/dev/console 将日志消息转发到本地主机的终端
/dev/lpr 将日志消息转发到打印机打印
| program 通过管道将日志消息转发给某个程序
file_name 将日志消息写入 file_name 指定的文件（文件使用绝对路径）
user_list 将日志转发给用户列表 user_list 指定的用户，用户名之间使用逗号隔开
（4）syslog.conf 文件的默认设置
/etc/syslog.conf 文件的默认设置如图 7.1 所示。
[root@localhost ~]# more /etc/syslog.conf
图 7.1 syslog.conf 默认设置
其中，行“*.info；mail.none；authpriv.none;cron.none /var/log/messages”表
示匹配 mail、authpriv、cron 等多个设备。
3. 配置 syslogd
例如，将一般性的日志消息保存到/var/log/messages 文件中，但不包括邮件、新闻
组、本地安全认证、守护进程以及 cron 程序产生的日志消息，可以配置如图 7.2 所示的行。
[root@localhost ~]# vi /etc/syslog.conf
图 7.2 配置 messages 文件日志内容
如将与打印机相关的日志信息发送到 pringinf.zsu.edu.cn 主机上，由该主机的
syslog 日志系统记录，可以配置如图 7.3 所示的行。
[root@localhost ~]# vi /etc/syslog.conf
图 7.3 配置打印机日志
说明：syslog.conf 文件修改后，需要重启 syslogd 守护进程才能应用新的配置。
4. 测试 f syslog.conf 文件
syslog.conf 文件修改后，使用者按照 syslog.conf 文件中的设置，使用 logger 命令
发出指定类型的日志消息，检测配置文件是否正确。logger 命令的格式如下：
logger [选项] msg
该命令常用的参数及含义如表 7.6 所示。
表 7.6 logger 常用的参数及含义
参数 含 义
-p fac.pr logger 命令发送消息时使用 fac.pri 指定的设备和优先级
-f conf_file logger 命令使用 conf_file 指定的 syslogd 配置文件
-i 记录发送消息的 logger 程序的 pid
-s 将 logger 程序发送的日志消息送往标准错误输出
-u socket 将 logger 程序发送的日志投递到指定的 socket 套接口
-d 使用 UDP 协议传输日志消息
例 7.1:“测试 syslog.conf 文件中“*.emerg *”部分。
在终端提示符下使用下的命令。
[root@localhost ~]# logger -p kern.emerg “this is syslog.conf test”
命令返回如图 7.4 所示的结果。
图 7.4 logger 发送日志消息
5. 清空日志文件
随着系统的运行时间不断延长，日志文件也会越来越大，从而消耗大量磁盘空间。如
果通过先删除已有的日志文件，再重建同名日志文件的方法来清空日志，就需要先停止创
建日志文件的服务进程，从而可能导致服务进程出错。此时，可以通过 echo 命令在不必停
止服务进程的情况下清空日志文件。具体的方法是在终端提示符选下输入如下命令：
[root@localhost ~]# echo “” > log_file
其中 log_file 代表需要清空的日志文件。例如，要清空日志文件/var/log/messages，
可以使用如下命令：
[root@localhost ~]# echo “” > /var/log/messages
7.2.3 日志系统
Linux 系统中提供了查看日志的命令行工具和图形工具，用户可以使用这些工具查看
Linux 的系统日志。
1 1 ． 使用命令查看日志
/var/log/boot.log 文 件 记 录 了 与 启 动 和 终 止 守 护 进 程 相 关 的 信 息 。
/var/log/messages 文件记录了系统除邮件、新闻组、本地安全认证、守护进程以及 cron
程序日志以外几乎全部的日志信息。这些日志文件时使用文本方式记录的，所以可以使用
查看文本文件的工具来查看，如 cat、more、tail 和 less 等。
例：使用 tail 命令查看 messages 日志的如图 7.5 所示。
[root@localhost ~]# tail -4 /var/log/messages
图 7.5 messages 日志内容
在 messages 日志文件中，每行记录一个日志事件，每个事件包括如下的字段：
（1）时间标签：表示消息发出的日期和时间。
（2）主机名：表示生成消息的计算机的名字。如果只有一台计算机，主机名就可能没
有必要了，但是，如果在网络环境中使用 syslog，那么可以把不同主机的日志消息发送到
一台服务器上集中处理。
（3）生成消息的子系统的名字：可以是“kernel”，表示消息来自内核，或者是进程
的名字，表示发出消息的程序的名字。
（4）消息：即是日志内容。
utmp 和 wtmp 日志文件是多数 Linux 日志系统的关键文件，它保存了用户登录和注销
的记录。有关当前登录用户的信息记录在 utmp 文件中，登录、注销、数据交换、关机以及
重启等信息都记录在 wtmp 文件中。所有的记录都包含时间戳（即文件的创建、修改和访问
时间）。
在 Linux 系统中 wtmp 和 utmp 是二进制文件，可以使用 last 命令来查看 wtmp 文件内
容。其使用格式如下：
last [选项]
该命令常用的参数及含义如表 7.7 所示。
表 7.7 last 命令参数及含义
参数 含义
-R 省略主机名字段
-n 只显示前 n 条信息
username 显示 username 指定的用户登录信息
tty 只显示从 tty 终端登录的信息
例 7.2:查看 root 近期登录的信息。
在终端提示符下执行如下的命令：
[root@localhost ~]# last -10 root
结果如图 7.6 所示
图 7.6 last 命令使用
last 命令查看的 wtmp 文件内容包括登录用户名、登录的终端、产生日志的主机网络
地址、日志产生的时间、当前用户状态和时间戳 6 个字段。
who 命令默认时报告当前登录的每个用户，查看的是 utmp 文件的信息，但也可以指明
查看 wtmp 文件的信息。如图 7.7 所示为使用 who 命令查询 utmp 文件并报告当前登录的用
户信息，默认输出包括用户名、终端类型、登录日期及远程主机。
[root@localhost ~]# who
图 7.7 who 查看 utmp 文件
who 命令还可以通过指定文件名的方法来查看 wtmp 日志文件的信息，如图 7.8 所示。
[root@localhost ~]# who /var/log/wtmp
图 7.8 who 查看 wtmp 文件
日志文件/var/log/dmesg 存放了系统启动时内核产生的日志，记录了内核对硬件的配
置过程。首先从 BIOS 开始，然后依次查找 CPU、硬盘驱动器、PCI 设备和通信端口，接下
来启动分区上的文件系统，最后配置键盘和鼠标等其他设备。使用 dmesg 命令可以查看该
文件的信息，如右图所示。
从图 7.9 可以看出在主机使用的内存容量为 727MB，机器实际安装的内存为 948MB，则
可以从该日志中判断多余的内存被 Linux 系统识别为 221MB。
[root@localhost ~]# vi /var/log/dmesg
图 7.9 dmesg 日志
7.3 Linux 用户安全
Linux 的用户安全包括账号安全和口令安全两个部分。
7.3.1 Linux 账号安全
1. 删除多余账号
在 Linux 系统中默认添加的各种账号中，有很多是无用的，或者有部分账号因为没有
启动该服务而成为多余账号，例如，如果不使用 ssh 服务器，那么 sshd 账号就是多余账号，
如果不使用匿名的 ftp 服务，那么账号 ftp 即为多余。账号越多，系统越容易受到攻击。
系统管理员应该在第一次使用系统时检查并删除不需要的账号。
在终端提示符下使用如下的命令即可删除多余的账号。
[root@localhost ~]# userdel mail
如果没有使用 sendmail 服务器，删除该用户在没有开启相应的服务的时候，如下的账
号都可以删除：adm、lp、sync、halt、mail、mailnull、games、news、sshd、gopher、
uucp、ftp、operator、named 等。
t 2. root 账号安全
在 Linux 系统中，所有的管理功能都能由 root 账号完成的，它是系统的超级用户。root
账号能对系统的所有资源做最大限度的调整，还可以直接允许或禁用单个用户、一部分用
户或所有用户对系统的访问。root 账号还可以控制用户的访问权限以及用户存放文件的位
置，可以控制用户能够访问的哪些系统资源，因此不能把 root 账号当作普通用户来使用。
在 Linux 系统中的/etc/securetty 文件中包含了一组能够以 root 账号登录的终端名
称。该文件的初始值仅允许本地虚拟控制台可以使用 root 登录，而不允许远程用户以 root
账号登录。虽然可以通过修改该文件的方法，允许 root 账号从远程主机登录，但是不建议
这样做。而是先使用普通账号从远程登录 Linux 主机，然后再使用 su 命令升级为超级用户，
当 root 账号使用完毕后，再使用 exit 命令注销。如果需要授权其他用户以 root 身份运行
某些命令时可以使用 sudo 命令。
该命令使用的基本格式如下：
sudo <command_line>
其中 command_line 为需要以 root 身份运行的命令行，如图 7.10 所示。
[root@localhost ~]# sudo more /etc/shadow
图 7.10 sudo 用法
需要注意的是，如果用户在离开时忘记从系统中注销，特别是 root 账号离开时忘记注
销，会给系统带来不可预知的隐患。Linux 系统可以控制系统在空闲时自动从 shell 中注
销，/etc/profile 文件中的“timeout”变量即为空闲的超时时间，例如：
timeout = 600
表示用户在 600 秒内无操作后将自动注销。
3. 用户信息文件安全
在 Linux 系统中，用户的信息都被保存在/etc/passwd 和/etc/shadow 文件中，用户组
的信息保存在/etc/group 和/etc/gshadow 文件中。为了防止攻击者偷窥用户和组信息，应
该按如下方式设置这些文件的访问权限：
[root@localhost ~]# chmod 600 /etc/passwd
[root@localhost ~]# chmod 600 /etc/shadow
[root@localhost ~]# chmod 600 /etc/group
[root@localhost ~]# chmod 600 /etc/gshadow
为了防止非授权用户通过修改用户信息文件和用户组文件修改用户口令和组群资料，
可以给这些文件添加不可更改的属性，这时可使用 chattr 命令，其格式如下：
chattr [mode] -R file_name
其中，参数-R 表示递归设置目录中所有文件的属性。mode 是文件的属性，可以使用“+”
表示添加某种属性，“-”表示取消某种属性，“=”表示具有某种属性。
其可以设置的属性如表 7.8 所示。
表 7.8 chattr 常用的文件属性
属性 说明
A 不允许更新访问时间
S 同步更新文件
D 同步更新目录内容
a 仅允许追加更新
d 不允许清空文件
i 不允许修改文件内容
例 7.3:在终端提示符下输入如下的命令可以设置/etd/passwd 文件、/etc/shadow 文
件、/etc/group 文件和/etc/gshadow 文件的不可修改属性。
[root@localhost ~]# chattr +i /etc/passwd
[root@localhost ~]# chattr +i /etc/shadow
[root@localhost ~]# chattr +i /etc/group
[root@localhost ~]# chattr +i /etc/gshadow
4. 关于 d setuid 属性
在 Linux 系统中，一些应用程序被设置了 setuid 属性。这些程序在运行时，能有效地
将当前执行该程序的用户的 uid 改变成应用程序所有者的 uid，使得应用程序进程在很大
程度上拥有该程序所有者的特权。如果被设置了 setuid 属性的应用程序归 root 所有，那
么该进程在运行时就会自动拥有超级用户的特权，即使该进程不是 root 用户启动的，如
/usr/bin/passwd 程序。
由于具有 setuid 属性的程序在运行时能够拥有 root 账号，会给系统带来一定的安全
隐患，因此应该尽可能减少应用程序设置 setuid 属性。做到除非必要，否则尽量不要给应
用程序设置 setuid 属性。系统管理员，可以使用 find 命令查找系统中所有被设置了 setuid
属性的应用程序。在终端提示符下，输入如下的 find 命令，搜索结果如图 7.11 所示。
[root@localhost ~]# find / -perm -4000
图 7.11 设置了 setuid 属性的应用程序
对于非必要的被设置了 setuid 属性的应用程序，可以在终端提示符下使用 chmod 命令
将其除去，例如除去/usr/bin/rcp 程序 setuid 属性的命令如下：
[root@localhost ~]# chmod -s /usr/bin/rcp
7.3.2 用户口令安全
口令是 Linux 系统对用户进行认证的主要手段，口令安全是 Linux 系统安全的基石。
不幸的是，用户往往对自己的口令安全没有足够的重视。一个简单、易破解的口令就等于
向对攻击者敞开系统的大门，攻击者一旦获得重要账号的口令，就能够长驱直入。
通常入侵者可以使用 John 等自动化的工具软件多次尝试登录系统，简单的口令很容易
被破解。一个健壮性高的口令应该具备以下特点：不包含个人信息，不存在键盘顺序规律，
不使用字典中的单词，最好包含非字母符号，长度不小于 8 位，同时还用方便记忆。一个
比较使用的办法就是：先记住一句话，然后将这句话的第一个字母取出，在将标点符号加
在字母的序列中，前后还可以加几个数字，同时可以在口令中混用大小写，例如：本教材
名为《Linux 操作系统基础应用及原理》，可以写成口令“77<Lczxtjcyyjyl>”，这便是
一个健壮的口令。
在 Linux 系统中，大多数版本的 passwd 程序都可以设置一定的规范来定义用户口令，
例如要求用户设置的口令不得少于 8 个字符，还可以限定用户口令使用的时间，保证定期
更改口令等。编辑系统登录文件/etc/login.defs 可以实现上述目标。该文件中有如下的
行：
PASS_MAX_DAYS 99999 口令使用的最长时间
PASS_MIN_DAYS 0 口令使用的最短时间，0 表示不限
PASS_MIN_LEN 8 口令的最小长度
PASS_WARN_AGE 7 在口令过期前多少天给出警告
访问控制和身份认证是计算机系统安全的两个重要的方面。访问控制用于判定网络中
允许访问主机资源的是不是合法的网络段的主机，身份认证用于判定访问主机资源的用户
是否为合法的系统用户。
7.3.3 TCP Wrappers
在 Linux 操作系统中 TCP Wrappers 是用于实现访问控制的一个重要的组件,可以控制
基于网络地址对主机的某些网络服务的访问，这些服务包括 xinetd、vsFTP、telnet 等。
如果系统支持TCP Wrappers实现访问控制，可以在/usr/lib/目录下找到libwrap.so.0.x.x
模块。
s 1. TCP Wrappers 的功能
TCP Wrappers 是一个轻量级的保护程序，它提供了一个守护进程/usr/sbin/tcpd。TCP
Wrappers 安装和使用的时候并不需要对现有的应用软件进行任何的改动，运行后会自动检
查所请求的服务和相应的客户端进行安全验证，在整个过程中，不会与客户端和服务器交
换信息及建立连接。常见的支持 TCP Wrappers 的网络服务程序有/usr/sbin/sshd、
/usr/sbin/sendmail 和/usr/sbin/xinetd 等。
s 2. TCP Wrappers 的配置
TCP Wrappers 的配置包括开启服务进程都 TCP Wrappers 的支持和设定访问控制策略。
例如，可以在 vsFTP 服务的配置文件/etc/vsftpd/vsftpd.conf 中有如下的配置行，用于
决定是否开启 vsftpd 对 TCP Wrappers 的支持：
tcp_wrappers=YES 取值 YES 表示支持 TCP Wrappers；NO 表示不支持
TCP Wrappers 会在正常的服务程序之外加一个应答请求、建立连接之前检查远程主机
名称和用户等信息，查看是否符合预先的设定。在Linux 系统的/etc/目录中有hosts.allow
和 hosts.deny 文件，用于保存 TCP Wrappers 基于主机地址的访问控制策略。其中，
hosts.allow 用于保存允许访问的策略；hosts.deny 用于保存拒绝访问的策略。
hosts.allow 和 hosts.deny 文件拥有相同的语法，一行代表对一个服务的访问控制策
略，每一行的前两个字段是必须有的，动作字段是可以可选的，具体语法如下：
服务程序列表：客户机地址列表[：动作]
其中，“服务程序列表”字段表示使用访问控制的服务程序，可能的取值及含义如表
7.9 所示。
表 7.9 服务程序列表取值及含义
取值 说明
ALL 代表所有的服务程序
serv_name
代表具体的服务程序。例如，in.telnetd 代表 telnet 服务器
程序， vsftpd 代表 vsftpd 服务器程序
serv_name1,serv_name2 代表多个服务程序同时使用该设置，如“in.telnetd,vsftpd”
“客户机地址列表”字段指明了拒绝或允许访问服务的客户机的 IP 地址或主机名等，
其可能的取值及含义如表 7.10 所示。
表 7.10 客户机地址列表取值及含义
取值 说明
ALL 代表所有的客户机地址
LOCAL 代表本机地址
KNOW 代表可解析的域名
UNKNOW 代表不可解析的域名
以句点“.” 开始的域
名
代表该域下的所有主机。例如“.aust.edu.cn”代表
aust.edu.cn 域中的所有主机
子网/掩码
对某个子网中的所有主机使用“子网/掩码”的形式表示，
例如，“210.45.151.0/24”表示标准 C 类网络 210.45.151.0
下的所有主机
直接使用 IP 地址 对于网络中的某个主机可直接使用 IP 地址表示
“动作”字段表示允许或拒绝客户机访问。可选取值及含义如表表 7.11 所示。
表 7.11 动作字段取值及含义
取值 说明
allow
表示允许，hosts.allow 文件中默认是 allow，可以省略不
写；
deny
表示拒绝，hosts.deny 文件文件中默认是 deny，可以省略
不写。
对于 hosts.allow 文件和 hosts.deny 文件，tcpd 守护进程首先解析/etc/hosts.allow
文件，如果发现第一个匹配规则后退出，并且不再解析 hosts.deny，否则接着解析
/etc/hosts.deny，找到第一个匹配规则后退出。如果在这两个文件中都没有找到匹配的规
则，或这两个文件都不存在，那么就授予访问这项服务的权限。
TCP Wrappers 并不缓存主机访问文件中的规则，因此对 hosts.allow 或 hosts.deny
的配置改变都无需重新启动网络服务便会马上起作用。
例 7.4:配置 TCP Wrappers，完成以下的访问控制功能：
（1）使用TCP Wrappers对vsftpd服务和telnet服务进行基于主机的访问控制，vsftpd
服务器和 telnet 服务器所在主机的地址为“192.168.1.7”；
（2）对于 vsftpd 服务只允许 IP 地址为“192.168.1.9”至“192.168.1.200”的主机
进行访问；
（3）由于 telnet 服务不安全，因此只允许 IP 地址为“192.168.1.122”的客户机访
问。
7.4 习题
1.简述 TCP Wrappers 的基本功能.
2. 简述口令安全的一些基本要求.
3.一般情况下如果用户在离开时忘记从系统中注销，特别是 root 账号离开时忘记注
销，会给系统带来不可预知的隐患,能否说说有为什么?并设置自动注解.
4. 在 Linux 系统中，用户的信息都被保存在/etc/passwd 和/etc/shadow 文件中，用
户组的信息保存在/etc/group 和/etc/gshadow 文件中。为了防止攻击者偷窥用户和组信
息，如何设置这些文件的访问权限,并添加不可更改的属性.
5. 使用 tail 命令查看 messages 日志,并找出一个时间标签,主机名,生成消息的子系统的
名字和消息相关信息.
6. 将一般性的日志消息保存到/var/log/messages 文件中，但不包括邮件、新闻组、
本地安全认证、守护进程以及 cron 程序产生的日志消息,并清空日志文件.



第 八 章 进程管理
在多道程序系统中，可能同时有多个运行的程序，其共享资源，相互之间制约和依赖，
轮流使用 CPU，表现出复杂的行为特性。而进程是为描述并发程序的执行过程而引入的概
念，进程管理就是对并发程序的运行过程的管理，也就是对处理器的管理。其功能是跟踪
和控制所有进程的活动，为分配和调度 CPU，协调进程的运行步调。其目标是最大限度地
发挥 CPU 的处理能力，提高进程的运行效率。
8.1 进程
进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资
源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，
进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。
程序是指令、数据及其组织形式的描述，进程是程序的实体。
进程是现代操作系统的核心概念，它用来描述程序的执行过程，是实现多任务操作系
统的基础。操作系统的其他所有内容都是围饶着进程展开的。因此，正确地理解和认识进
程是理解操作系统原理的基础和关键。
8.1.1 程序的顺序执行与并发执行
1．程序的顺序执行
如果程序的各操作步骤之间是依序执行的，程序与程序之间是串行执行的，这种执行
程序的方式就称为顺序执行。顺序执行是单道程序系统中的程序的运行方式。
程序的顺序执行具有如下特点：
（1）顺序性：CPU 严格按照程序规定的顺序执行，仅当一个操作结束后，下一个操
作才能开始执行。多个程序要运行时，仅当一个程序全部执行结束后另一个程序才能开始。
（2） 封闭性：程序在封闭的环境中运行，即程序运行时独占全部系统资源，只有程
序本身才能改变程序的运行环境。因而程序的执行过程不受外界因素的影响，结果只取决
于程序自身。
（3）可再现性：程序执行的结果与运行的时间和速度无关，结果总是可再现的，即无
论何时重复执行该程序都会得到同样的结果。
总的说来，这种执行程序的方式简单，且便于调试。但由于顺序程序在运行时独占全
部系统资源，因而系统资源利用率很低。DOS 程序就是采用顺序方式执行的。
2. 程序的并发执行
单道程序、封闭式运行是早期操作系统的标志，而多道程序并发运行是现代操作系统
的基本特征。由于同时有多个程序在系统中运行，使系统资源得到充分的利用，系统效率
大大提高。
程序的并发执行是指若干个程序或程序段同时运行。它们的执行在时间上是重叠的，
即同一程序或不同程序的程序段可以交叉执行。
程序的并发执行有以下特点：
（1）间断性：并发程序之间因竞争资源而相互制约，导致程序运行过程的间断。例如，
在只有一个 CPU 的系统中，多个程序需要轮流占用 CPU 运行，未获得 CPU 使用权的程序
就必须等待。
（2）没有封闭性：当多个程序共享系统资源时，一个程序的运行受其他程序的影响，
其运行过程和结果不完全由自身决定。例如，一个程序计划在某一时刻执行一个操作，但
很可能在那个时刻到来时它没有获得 CPU 的使用权，因而也就无法完成该操作。
（3）不可再现性：由于没有了封闭性，并发程序的执行结果与执行的时机以及执行的
速度有关，结果往往不可再现。
可以看出，并发执行程序虽然可以提高系统的资源利用率和吞吐量，但程序的行为变
得复杂和不确定。这使程序难以调试，若处理不当还会带来许多潜在问题。
3. 并发执行的潜在问题
程序在并发执行时会导致执行结果的不可再现性，这是多道程序系统必须解决的问题。
我们用下面的例子来说明并发执行过程对运行结果的影响，从而了解产生问题的原因。
例 8.1:某学校使用程序控制来显示某门选修课还未选的空闲数（设允许选择也可以退
选）。空闲数用一个计数器 D 记录。学生已选时执行程序 A，学生退选此门课时执行程序
B，它们都要更新同一个计数器 D。程序 A 和程序 B 的片段如下所示。
Program A
{
…
read D into N;
N=N-1;
output N to D;
….
}
Program B
{
…
read D into M;
M=M-1;
output M to D;
….
}
D
更新计数器 D 的操作对应的机器语言有 3 个步骤：读取内存 D 单元的数据到一个寄存
器中，修改寄存器的数值，然后再将其写回 D 单元中。
由于学生选课的时间是随机的，程序 A 与程序 B 的运行时间也就是不确定的。当同时
有学生选课和有学生退选同时发生时，将使两程序在系统中并发运行。它们各运行一次后
D 计数器的值应保持不变。但结果可能不是如此。
如果两个程序的运行时序按表 8.1 所示的顺序进行，即一个程序对 D 进行更新的操作
是在另一个程序的更新操作全部完成之后才开始，则 D 被正确地更新了。如果两个程序的
运行时序如表 8.2 所示穿插地进行，即当一个程序正在更新 D，更新操作还未完成时，CPU
发生了切换，另一个程序被调度运行，并且也对 D 进行更新。在这种情况下会导致错误的
结果。
可以看出，导致 D 更新错误的原因是两个程序交叉地执行了更新 D 的操作。概括地说，
当多个程序在访问共享资源时的操作是交叉执行时，则会发生对资源使用上的错误。
表 8.1 两个程序顺序访问 D，更新正确
时间 T0 T1 T2 T3 T4 T5
程序 A D→N N-1 N→D
程序 B D→M M+1 M→D
D 的值 100 100 99 99 99 100
表 8.2 两个程序交叉访问 D，更新错误
时间 T0 T1 T2 T3 T4 T5
程序 A D→N N-1 N→D
程序 B D→M M+1 M→D
D 的值 100 100 100 100 99 101
8.1.2 进程的概念
进程的概念最早出现在 20 世纪 60 年代中期，此时操作系统进入多道程序设计时代。
多道程序并发显著地提高了系统的效率，但同时也使程序的执行过程变得复杂而不确定。
为了更好地研究、描述和控制并发程序的执行过程，操作系统引入了进程的概念。进程概
念对于理解操作系统的并发性有着极为重要的意义。
1. 进程
进程(process)是一个可并发执行的程序在某数据集上的一次运行。简单地说，进程就
是程序的一次运行过程。
进程与程序的概念既相互关联又相互区别。程序是进程的一个组成部分，是进程的执
行文本，而进程是程序的执行过程。两者的关系可以比喻为电影与胶片的关系：胶片是静
态的，是电影的放映素材。而电影是动态的，一场电影就是胶片在放映机上的一次“运行”。
对进程而言，程序是静态的指令集合，可以永久存在；而进程是个动态的过程实体，动态
地产生、发展和消失。
此外，进程与程序之间也不是一一对应的关系，表现在：
一个进程可以顺序执行多个程序，如同一场电影可以连续播放多部胶片一样。
一个程序可以对应多个进程，就像一本胶片可以放映多场电影一样。程序的每次运行
就对应了一个不同的进程。更重要的是，一个程序还可以同时对应多个进程。比如系统中
只有一个 vi 程序，但它可以被多个用户同时执行，编辑各自的文件。每个用户的编辑过程
都是一个不同的进程。
2. 进程的特性
进程与程序的不同主要体现在进程有一些程序所没有的特性。要真正理解进程，首先
应了解它的基本性质。进程具有以下几个基本特性：
动态性：进程由“创建”而产生，由“撤销”而消亡，因“调度”而运行，因“等待”
而停顿。进程从创建到消失的全过程称为进程的生命周期。
并发性：在同一时间段内有多个进程在系统中活动。它们宏观上是在并发运行，而微
观上是在交替运行。
独立性：进程是可以独立运行的基本单位，是操作系统分配资源和调度管理的基本对
象。因此，每个进程都独立地拥有各种必要的资源，独立地占有 CPU 并独立地运行。
异步性：每个进程都独立地执行，各自按照不可预知的速度向前推进。进程之间的协
调运行由操作系统负责。
3. 进程的基本状态
在多道系统中，进程的个数总是多于 CPU 的个数，因此它们需要轮流地占用 CPU。从
宏观上看，所有进程同时都在向前推进，而在微观上，这些进程是在走走停停之间完成整
个运行过程的。为了刻画一个进程在各个时期的动态行为特征，通常采用状态图模型。
程有 3 个基本的状态，即：
就绪态：进程已经分配到了除 CPU 之外的所有资源，这时的进程状态称为就绪状态。
处于就绪态的进程，一旦获得 CPU 便可立即执行。系统中通常会有多个进程处于就绪态，
它们排成一个就绪队列。
运行态：进程已经获得 CPU，正在运行，这时的进程状态称为运行态。在单 CPU 系统
中，任何时刻只能有一个进程处于运行态。
等待态：进程因某种资源不能满足，或希望的某事件尚未发生而暂停执行时，则称它
处于等待态。系统中常常会有多个进程处于等待态，它们按等待的事件分类，排成多个等
41
待队列。
4. 进程状态的转换
进程诞生之初是处于就绪状态，在其随后的生存期间内不断地从一个状态转换到另一
个状态，最后在运行状态结束。图 8.1 所示是一个进程的状态转换图。
图 8.1 进程的态转换图
引起状态转换的原因如下：
运行态→等待态：正在执行的进程因为等待某事件而无法执行下去，比如，进程申请
某种资源，而该资源恰好被其他进程占用，则该进程将交出 CPU，进入等待状态。
等待态→就绪态：处于等待状态的进程，当其所申请的资源得到满足，则系统将资源
分配给它，并将其状态变为就绪态。
运行态→就绪态：正在执行的进程的时间片用完了，或者有更高优先级的进程到来，
系统会暂停该进程的运行，使其进入就绪态，然后调度其他进程运行。
就绪态→运行态：处于就绪状态的进程，当被进程调度程序选中后，即进入 CPU 运行。
此时该进程的状态变为运行态。
8.1.3 进程控制块
进程由程序、数据和进程控制块 3 部分组成，其中程序是进程执行的可执行代码，数
据是进程所处理的对象，进程控制块记录进程的所有信息。它们存在于内存，其内容会随
着执行过程的进展而不断变化。在某个时刻的进程的内容被称为进程映像(process image)。
系统中每个进程都是唯一的，用一个进程控制块描述。即使两个进程执行的是同一程
序，处理同一数据，它们的进程控制块也是不同的。因此可以说，进程控制块是进程的
标志。
1. 进 进 程控制块
进程控制块(Process Control Block，PCB)是系统为管理进程设置的一个数据结构，用于
记录进程的相关信息。PCB 是系统感知和控制进程的一个数据实体。当创建一个进程时，
系统为它生成 PCB；进程完成后，撤销它的 PCB。因此，PCB 是进程的代表，PCB 存在则
进程就存在，PCB 消失则进程也就结束了。在进程的生存期中，系统通过 PCB 来了解进程
的活动情况，对进程实施控制和调度。因此，PCB 是操作系统中的最重要数据结构之一。
2. 进程控制块的内容
PCB 记录了有关进程的系统所关心的所有信息，主要包括以下 4 方面的内容：
（1）进程描述信息
进程描述信息用于记录一个进程的特征和基本情况，通过这些信息可以识别该进程，
了解该进程的归属信息，以及确定这个进程与其他进程之间的关系。
系统为每个进程分配了一个唯一的整数作为进程标识号 PID，通过这个 PID 来标识这
个进程。操作系统、用户以及其他进程都是通过 PID 来识别进程的。此外，还要描述进程
的家族关系，即父进程(创建该进程的进程)和子进程(该进程创建的进程)的信息。
（2）进程控制和调度信息
进程是系统运行调度的基本单位。进程控制块记录了进程的当前状态、调度信息、记
时信息等。系统依据这些信息确定进程的状态，实施进程控制和调度。
（3）资源信息
系统以进程为单位分配资源，并将资源信息记录在进程的 PCB 中。资源包括该进程使
用的存储器空间、打开的文件以及设备等。通过这些信息，进程就可以得到运行需要的相
关程序段与数据段、使用文件和设备等资源。
（4）现场信息
现场信息一般包括 CPU 的内部寄存器和系统堆栈等，它们的值刻画了进程的运行状
态。退出 CPU 的进程必须保存好这些现场状态，以便在下次被调度时继续运行。当一个进
程被重新调度运行时，要用 PCB 中的现场信息来恢复 CPU 的运行现场。现场一旦切换，
下一个指令周期 CPU 将精确地接着上次运行的断点处继续执行下去。
8.1.4 进程的组织
管理进程就是管理进程的 PCB。一个系统中通常可能拥有数百乃至上千个进程，为了
有效地管理如此多的 PCB，系统需要采用适当的方式将它们组织在一起。所有的 PCB 都存
放在内存中，通常采用的组织结构有数组、索引和链表 3 种方式。
数组方式是将所有的 PCB 顺序存放在一个一维数组中。这种方式比较简单，但操作起
来效率低，比如，要查找某个 PCB 时需要扫描全表。
索引方式是通过在 PCB 数组上设置索引表或散列表，以加快访问速度。
链表方式是将 PCB 链接起来，构成链式队列或链表。例如，所有就绪的 PCB 链成一
个就绪队列；所有等待的 PCB 按等待的事件链成多个等待队列。这样，在进程调度时只要
扫描就绪队列即可，等待的事件发生时只要扫描相应的等待队列即可。当进程状态发生转
换时，链式结构允许方便地向队列插入和删除一个 PCB。
实际的系统中通常会结合采用这些方法，以求达到最好的效率。
8.1.4 Linux 系统中的进程
在 Linux 系统中，进程也称为任务(task)，两者的概念是一致的。
1. Linux 进程的状态
Linux 的进程共有 5 种基本状态，包括运行、就绪、睡眠(分为可中断的与不可中断的)、
暂停和僵死。状态转换图如图 8.2 所示。
图 8.2 Linux 系统的进程状态转换图
Linux 将这些基本状态归结为 4 种并加以命名和定义，它们是：
（1）可执行态(runnable)：可执行态实际包含了上述基本状态中的运行和就绪两种状
态。处于可执行态的进程均已具备运行条件。它们或正在运行，或准备运行。
（2）睡眠态(sleeping)：即等待态。进程在等待某个事件或某个资源。睡眠态又细分为
可中断的(interruptible)和不可中断的(uninterruptible)两种。它们的区别在于，在睡眠过程中，
不可中断状态的进程会忽略信号，而处于可中断状态的进程如果收到信号会被唤醒而进入
可执行状态，待处理完信号后再次进入睡眠状态。
（3）暂停态(stopped)：处于暂停态的进程一般都是由运行态转换而来，等待某种特殊
处理。比如调试跟踪的程序，每执行到一个断点，就转入暂停态，等待新的输入信号。
（4）僵死态(zombie)：进程运行结束或因某些原因被终止时，它将释放除 PCB 外的所
有资源。这种占有 PCB 但已经无法运行的进程就处于僵死状态。
2. Linux 进程的状态转换过程
Linux 进程的状态转换过程是：新创建的进程处于可执行的就绪态，等待调度执行。
处于可执行态的进程在就绪态和运行态之间轮回。就绪态的进程一旦被调度程序选中，
就进入运行状态。等时间片耗尽之后，退出 CPU，转入就绪状态等待下一次的调度。处于
此轮回的进程在运行与就绪之间不断地高速切换，可谓瞬息万变。因此，对观察者(系统与
用户)来说，将此轮回概括为一个相对稳定的可执行态才有意义。
运行态、睡眠态和就绪态形成一个回路。处于运行态的进程，有时需要等待某个事件
或某种资源的发生，这时已无法占有 CPU 继续工作，于是它就退出 CPU，转入睡眠状态。
当所等待的事件发生后，进程被唤醒，进入就绪状态。
运行态、暂停态和就绪态也构成一个回路。当处于运行态的进程接收到暂停执行信号
时，它就放弃 CPU，进入暂停态。当暂停的进程获得恢复执行信号时，就转入就绪态。
处于运行态的进程调用退出函数 exit 之后，进入僵死态。当父进程对该进程进行相应
的处理后，撤销其 PCB。此时，这个进程就完成了它的使命，从僵死走向彻底消失。
3. Linux 的进程控制块
Linux 系统的 PCB 用一个称为 task_struct 的结构体来描述。系统中每创建一个新的进
程，就给它分配一个 task_struct 结构，并填入进程的控制信息。task_struct 主要包括以下内
容：
（1）进程标识号(PID)：PID 是标识该进程的一个整数。系统通过这个标识号来唯一地
标识一个进程。
（2）用户标识(UID)和组标识(GID)：描述进程的归属关系，即进程的属主和属组的标
识号。系统通过这两个标识号判断进程对文件和设备的访问权限。
（3）链接信息：用指针的方式记录进程的父进程、兄弟进程以及子进程的位置(即 PCB
的地址)。系统通过链接信息确定进程的家族关系以及其在整个进程链中的位置。
（4）状态：进程当前的状态。
（5）调度信息：与系统调度相关的信息，包括优先级、时间片和调度策略。
（6）记时信息：包括时间和定时器。时间记录进程建立的时间以及进程占用 CPU 的
时间统计，是进程调度、统计和监控的依据。定时器用于设定一个时间。时间到时，系统
会发定时信号通知进程。
（7）通信信息：记录有关进程间信号量通信及信号通信的信息。
（8）退出码：记录进程运行结束后的退出状态，供父进程查询用。
（9）文件系统信息：包括根目录、当前目录、打开的文件以及文件创建掩码等信息。
（10）内存信息：记录进程的代码映像和堆栈的地址、长度等信息。
（11）进程现场信息：保存进程放弃 CPU 时所有 CPU 寄存器及堆栈的当前值。
4. 查看进程的信息
在 Linux 系统中，要查看进程的信息可使用 ps(process status)命令。该命令可查看记录
在进程 PCB 中的几乎所有信息。常用参数及含义如表 8.2 所示。
表 8.2 ps 常用参数及含义
参数 含义
-e
显示所有进程
-f
以全格式显示
-r
只显示正在运行的进程
-o
以用户定义的格式显示
a
显示所有终端上的所有进程
u
以面向用户的格式显示
x
显示所有不控制终端的进程
说明：
（1）默认只显示在本终端上运行的进程，除非指定了-e、a、x 等选项。
（2）没有指定显示格式时，采用以下缺省格式，分 4 列显示：PID TTY TIME CMD
各字段的含义是如表 8.3 所示。
表 8.3 ps 缺省格式
参数 含义
PID
进程标识号
TTY
进程对应的终端，？表示该进程不占用终端
TIME
进程累计使用的 CPU 时间
CMD
进程执行的命令名
（3）指定-f 选项时，以全格式，分 8 列显示：UID PID PPID C STIME TTY
TIME CMD
各字段的含义是如表 8.4 所示。
表 8.4 指定-f 选项
参数 含义
UID
进程属主的用户名
PPID
父进程的标识号
C
进程最近使用的 CPU 时间
STIME
进程开始时间
其余同表 8.3 所示。
（4）指定 u 选项时，以用户格式，分11列显示：USER PID %CPU %MEM VSZ RSS TTY
STAT START TIME COMMAND
各字段的含义是如表 8.5 所示。
表 8.5 指定 u 选项
参数 含义
USER
同 UID
%CPU
进程占用 CPU 的时间与进程总运行时间之比
%MEM
进程占用的内存与总内存之比
VSZ
进程虚拟内存的大小，以 KB 为单位
RSS
占用实际内存的大小，以 KB 为单位
STAT 进程当前状态，用字母表示。
R 执行态；
S 睡眠态；
D 不可中断睡眠态；
T 暂停态；
Z 僵尸态。
START
同 STIME
COMMAND
同 CMD
其余同上。
例 8.2：ps 命令用法示例：
1 ．以缺省格式显示本终端上的进程的信息
[root@localhost ~]#ps
如图 8.3 所示。
图 8.3 ps 显示
2 ．以全格式显示当前系统中所有进程的信息
[root@localhost ~]#ps –ef
如图 8.4 示。
图 8.4 ps –ef 显示
3 ．以用户格式显示当前系统中所有进程的信息
[root@localhost ~]#ps aux
如图 8.5 所示
图 8.5 ps aux 显示
8.2 进程的运行模式
进程的运行紧密依赖于操作系统的内核。因此，理解进程的运行机制需要首先认识内
核，了解内核的运行方式，进而了解进程在核心态与用户态下的不同执行模式。
8.2.1 操作系统内核
一个完整的操作系统由一个内核和一些系统服务程序构成。内核(kernel)是操作系统的
核心，它负责最基本的资源管理和控制工作，为进程提供良好的运行环境。
图 8.6 是 Linux 系统的层次体系结构。系统分为 3 层：最底层是系统硬件；硬件层之上
是核心层，它是运行程序和管理基本硬件的核心程序；用户层由系统的核外程序和用户程
序组成，它们都是以用户进程的方式运行在核心之上。
图 8.6 Linux 系统的内核结构
内核在系统引导时载入并常驻内存，形成对硬件的第一层包装。启动了内核的系统具
备了执行进程的所有条件，使进程可以被正确地创建、运行、控制和撤销。为此，内核应
具备支撑进程运行的所有功能，包括对进程本身的控制及对进程要使用的资源的管理。
Linux 系统的内核主要由以下成分构成：
（1）进程控制子系统，负责支持、管理和控制进程的运行，包括以下模块：
进程调度模块，负责调度进程的运行。
进程通信模块，实现进程间的本地通信。
内存管理模块，管理进程的地址空间。
（2）文件子系统，为进程提供 I/O 环境，包括以下模块和成分：
文件系统模块，管理文件和设备。
网络接口模块，实现进程间的网络通信。
设备驱动程序，驱动和控制设备的运行。
系统调用接口，提供进程与内核的接口，进程通过此接口调用内核的功能。
硬件控制接口，是内核与硬件的接口，负责控制硬件并响应和处理中断事件。
8.2.2 中断与系统调用
由图 8.6 可以看出，内核与外界的接口是来自用户层的系统调用和来自硬件层的中断，
而系统调用本身也是一种特殊的中断。因此可以说内核是中断驱动的，它的主要作用就是
提供系统调用和中断的处理。因此，了解内核的运行机制需要先了解中断和系统调用的概
念。
1. 中断
在早期的计算机系统中，CPU 与各种设备是串行工作的。当需要设备传输数据时，CPU
向设备发出指令，启动设备执行数据传输操作。然后 CPU 不断地测试设备的状态，直到它
完成操作。在设备工作期间，CPU 是处于原地踏步的循环中，这对 CPU 资源是极大的浪费。
中断技术的出现完全改变了计算机系统的操作模式。在现代系统中，CPU 与各种设备
是并发工作的。在中断方式下，CPU 启动设备操作后，它不是空闲等待，而是继续执行程
序。当设备完成 I/O 操作后，向 CPU 发出一种特定的中断信号，打断 CPU 的运行。CPU
响应中断后暂停正在执行的程序，转去执行专门的中断处理程序，然后再返回原来的程序
继续执行。这个过程就是中断。
中断的概念是因实现 CPU 与设备并行操作而引入的。然而，这个概念后来被大大地扩
大了。现在，系统中所有异步发生的事件都是通过中断机制来处理的，包括 I/O 设备中断、
系统时钟中断、硬件故障中断、软件异常中断等。这些中断分为硬件中断和软件中断(也称
为异常)两大类。每个中断都对应一个中断处理程序。中断发生后，CPU 通过中断处理入口
转入相应的处理程序来处理中断事件。关于中断技术的更多参考后面章节。
2. 系统调用
系统调用是系统内核提供的一组特殊的函数，用户进程通过系统调用来访问系统资源。
与普通函数的不同之处在于，普通函数是由用户或函数库提供的程序代码，它们的运行会
受到系统的限制，不能访问系统资源。系统调用是内核中的程序代码，它们具有访问系统
资源的特权。当用户进程需要执行涉及系统资源的操作时，需要通过系统调用，让内核来
完成。
系统调用是借助中断机制实现的，它是软中断的一种，称为“系统调用”中断。当进
程执行到一个系统调用时，就会产生一个系统调用中断。CPU 将响应此中断，转入系统调
用入口程序，然后调用内核中相应的系统调用处理函数，执行该系统调用对应的功能。关
于系统调用的更多参考后面章节。
8.2.3 进程的运行模式
1. CPU 的执行模式
CPU 的基本功能就是执行指令。通常，CPU 指令集中的指令可以划分为两类：特权指
令和非特权指令。特权指令是指具有特殊权限的指令，可以访问系统中所有寄存器和内存
单元，修改系统的关键设置。比如清理内存、设置时钟、执行 I/O 操作等都是由特权指令
完成的。而非特权指令是那些用于一般性的运算和处理的指令。这些指令只能访问用户程
序自己的内存地址空间。
特权指令的权限高，如果使用不当则可能会破坏系统或其他用户的数据，甚至导致系
统崩溃。为了安全起见，这类指令只允许操作系统的内核程序使用，而普通的应用程序只
能使用那些没有危险的非特权指令。实现这种限制的方法是在 CPU 中设置一个代表运行模
式的状态字，修改这个状态字就可以切换 CPU 的运行模式。
386 以上的 CPU 支持 4 种不同特权级别的运行模式，Linux 系统只用到了其中两个，
即称为核心态的最高特权级模式(ring0)和称为用户态的最低特权级模式(ring3)。在核心态
下，CPU 能不受限制地执行所有指令，从而表现出最高的特权。而在用户态下，CPU 只能
执行一般指令，不能执行特权指令，因而也就没有特权。内核的程序运行在核心态下，而
用户程序则只能运行在用户态下。从用户态转换为核心态的唯一途径是中断(包括系统调
用)。一旦 CPU 响应了中断，则将 CPU 的状态切换到核心态，待中断处理结束返回时，再
将 CPU 状态切回到用户态。
2. 进程的运行模式
进程在其运行期间常常被中断或系统调用打断，因此 CPU 也经常地在用户态与核心态
之间切换。在进行通常的计算和处理时，进程运行在用户态；执行系统调用或中断处理程
序时进入核心态，执行内核代码。调用返回后，回到用户态继续运行。图 8.7 描述了用户
进程的运行模式切换。
图 8.7 用户进程的运行模式切换
在 A 期间，进程运行在用户态，执行的是用户程序代码。运行到某一时刻时发生了中
断，进程随即“陷入”核心态运行。在 B 期间，CPU 运行在核心态，执行的是内核程序代
码。此时有两种情况：如果进程是被中断打断的，则 B 期间执行的是中断处理程序，它是
随机插入的，与进程本身无关；如果进程是因调用了系统调用而陷入内核空间的，则 B 执
行的是内核的系统调用程序代码，它是作为进程的一个执行环节，由内核代理用户进程继
续执行的。在中断或系统调用返回后的 C 期间中，进程在用户态继续运行。
8.3 进程控制
进程控制是指对进程的生命周期进行有效的管理，实现进程的创建、撤销以及进程各
状态之间的转换等控制功能。进程控制的目标是使多个进程能够平稳高效地并发执行，充
分共享系统资源。
8.3.1 进程控制的功能
进程控制的功能是控制进程在整个生命周期中各种状态之间的转换(不包括就绪态与
运行态之间的转换，它们是由进程调度来实现的)。为此，内核提供了几个原子性的操作函
数，称为原语(primitive)。原语与普通函数的区别是它的各个指令的执行是不可分割的，要
么全部完成，要么一个也不做，因而可以看做是一条广义的指令。用于进程控制的原语主
要有创建、终止、阻塞和唤醒等。
1 ．创建进程
创建原语的主要任务是根据创建者提供的有关参数(包括进程名、进程优先级、进程代
码起始地址、资源清单等信息)，建立进程的 PCB。具体的操作过程是：先申请一个空闲的
PCB 结构，调用资源分配程序为它分配所需的资源，将有关信息填入 PCB，状态置为就绪
态，然后把它插入就绪(可执行)队列中。
2 ．撤销进程
撤销原语用于在一个进程运行终止时，撤销这个进程并释放进程占用的资源。撤销的
操作过程是：找到要被撤销的进程的 PCB，将它从所在队列中摘出，释放进程所占用的资
源，最后销去进程的 PCB。
3 ．阻塞进程
阻塞原语用于完成从运行态到等待态的转换工作。当正在运行的进程需要等待某一事
件而无法执行下去时，它就调用阻塞原语把自己转入等待状态。阻塞原语具体的操作过程
是：首先中断 CPU 的执行，把 CPU 的当前状态保存在 PCB 的现场信息中；然后把被阻塞
的进程置为等待状态，插入到相应的等待队列中；最后调用进程调度程序，从就绪(可执行)
队列中选择一个进程投入运行。
4 ．唤醒进程
唤醒原语用于完成等待态到就绪态的转换工作。当处于等待状态的进程所等待的事件
出现时，内核会调用唤醒原语唤醒被阻塞的进程。操作过程是：在等待队列中找到该进程，
置进程的当前状态为就绪态，然后将它从等待队列中撤出并插入到就绪(可执行)队列中。
8.3.2 Linux 系统的进程控制
在 Linux 系统中，进程控制的功能是由内核的进程控制子系统实现的，并以系统调用
的形式提供给用户进程或其他系统进程使用。
1. 进程的创建与映像更换
系统启动时执行初始化程序，启动进程号为 1 的 init 进程运行。系统中所有的其他进
程都是由 init 进程衍生而来的。除 init 进程外，每个进程都是由另一个进程创建的。新创
建的进程称为子进程，创建子进程的进程称为父进程。
Unix/Linux 系统建立新进程的方式与众不同。它不是一步构造出新的进程，而是采用
先复制再变身的两个步骤，即先按照父进程创建一个子进程，然后再更换进程映像开始执
行。
（1）创建进程
创建一个进程的系统调用是 fork()。创建进程采用的方法是克隆，即用父进程复制一个
子进程。做法是：先获得一个空闲的 PCB，为子进程分配一个 PID，然后将父进程的 PCB
中的代码及资源复制给子进程的 PCB，状态置为可执行态。建好 PCB 后将其链接入进程链
表和可执行队列中。此后，子进程与父进程并发执行。父子进程执行的是同一个代码，使
用的是同样的资源。它与父进程的区别仅仅在于 PID(进程号)、PPID(父进程号)和与子进程
运行相关的属性(如状态、累计运行时间等)，而这些是不能从父进程那里继承来的。
fork()系统调用含义如表 8.6 所示。
表 8.6 fork()系统调
参数 含义
功能
创建一个新的子进程
调用格式
int fork();
返回值
0：向子进程返回的返回值，总为 0
> 0：向父进程返回的返回值，它是子进程的 PID
1：创建失败
说明：若 fork()调用成功，则它向父进程返回子进程的 PID，并向新建的子进程返回 0。
图 8.8 描述了 fork()系统调用的执行结果。
从图 8.8 中可以看出，当一个进程成功执行了 fork()后，从该调用点之后分裂成了两个
进程：一个是父进程，从 fork()后的代码处继续运行；另一个是新创建的子进程，从 fork()
后的代码处开始运行。由 fork()产生的进程分裂在结构上很像一把叉子，故得名 fork()。
与一般函数不同，fork()是“一次调用，两次返回”，因为调用成功后，已经是两个进
程了。由于子进程是从父进程那里复制的代码，因此父子进程执行的是同一个程序，它们
在执行时的区别只在于得到的返回值不同。父进程得到的返回值是一个大于 0 的数，它是
子进程的 PID；子进程得到的返回值为 0。
图 8.8 fork()系统调用的执行结果
若程序中不考虑 fork()的返回值，则父子进程的行为就完全一样了。但创建一个子进程
的目的是想让它做另一件事。所以，通常的做法是：在 fork()调用后，通过判断 fork()的返
回值，分别为父进程和子进程设计不同的执行分支。这样，父子进程执行的虽是同一个代
码，执行路线却分道扬镳。图 8.9 述了用 fork()创建子进程的常用流程。
图 8.9 用 fork 创建子进程
（2）更换进程映像
进程映像是指进程所执行的程序代码及数据。fork()是将父进程的执行映像拷贝给子进
程，因而子进程实际上是父进程的克隆体。但通常用户需要的是创建一个新的进程，它执
行的是一个不同的程序。Linux 系统的做法是，先用 fork()克隆一个子进程，然后在子进程
中调用 exec()，使其脱胎换骨，变换为一个全新的进程。
exec()系统调用的功能是根据参数指定的文件名找到程序文件，把它装入内存，覆盖原
来进程的映像，从而形成一个不同于父进程的全新的子进程。除了进程映像被更换外，新
子进程的 PID 及其他 PCB 属性均保持不变，实际上是一个新的进程“借壳”原来的子进程
开始运行。
exec()系统调用含义如表 8.7 所示。
表 8.7 exec()系统调用
参数 含义
功能
改变进程的映像，使其执行另外的程序
调用格式
exec()是一系列系统调用，共有 6 种调用格式，其中 execve()是真正的系统
调用，其余是对其包装后的 C 库函数：
int execve(char *path, char *argv[], char *envp[]);
int execl(char *path, char *arg0, char *arg1, ... char *argn, 0);
int execle(char *path, char *arg0, char *arg1, ... char *argn, 0, char *exvp[]);
…
其中：path 为要执行的文件的路径名，argv[]为运行参数数组，envp[]为运
行环境数组。arg0 为程序的名称，arg1～argn 为程序的运行参数，0 表示
参数结束。例如：
execl(“/bin/echo”, “echo”,“hello!”, 0);
execle(“/bin/ls”, “ls”, “-l”, “/bin”, 0, NULL);
前者表示更换进程映像为/bin/echo 文件，执行的命令行是“echo hello!”。
后者表示更换进程映像为/bin/ls 文件，执行的命令行是“ls -l /bin”。
返回值
调用成功后，不返回，调用失败后，返回－1。
与一般的函数不同，exec()是“一次调用，零次返回”，因为调用成功后，进程的映像
已经被替换，无处可以返回了。图 8.10 描述了用 exec()系统调用更换进程映像的流程。子
进程开始运行后，立即调用 exec()，变身成功后即开始执行新的程序了。
2. 进程的终止与等待
（ （1 ）进程的终止与退出状态
导致一个进程终止运行的方式有两种：一是程序中使用退出语句主动终止运行，我们
称其为正常终止；另一种是被某个信号杀死(例如，在进程运行时按 Ctrl+c 键终止其运行)，
称为非正常终止。关于信号的介绍见 0 节。
用 C 语言编程时，可以通过以下 4 种方式主动退出：
调用 exit(status)函数来结束程序；
在 main()函数中用 return status 语句结束；
在 main()函数中用 return 语句结束；
main()函数结束。
图 8.10 用 exec 更换子进程的映像
以上 4 种情况都会使进程正常终止，前 3 种为显式地终止程序的运行，后 1 种为隐式
地终止。正常终止的进程可以返回给系统一个退出状态，即前 2 种语句中的 status。通常的
约定是：0 表示正常状态；非 0 表示异常状态，不同取值表示异常的具体原因。例如对一
个计算程序，可以约定退出状态为 0 表示计算成功，为 1 表示运算数有错，为 2 表示运算
符有错，等等。如果程序结束时没有指定退出状态(如后两种退出)，则它的退出状态是不
确定的。
设置退出状态的作用是通知父进程有关此次运行的状况，以便父进程做相应的处理。
因此，显式地结束程序并返回退出状态是一个好的 Unix/Linux 编程习惯，这样的程序可以
将自己的运行状况告之系统，因而能很好地与系统和其他程序合作。
（2）终止进程进
进程无论以哪种方式结束，都会调用一个 exit()系统调用，通过这个系统调用终止自己
的运行，并及时通知父进程回收本进程。exit()系统调用完成以下操作：释放进程除 PCB 外
的几乎所有资源；向 PCB 写入进程退出状态和一些统计信息；置进程状态为“僵死态”；
向父进程发送“子进程终止(SIGCHLD)”信号；调用进程调度程序切换 CPU 的运行进程。
exit()系统调用含义如表 8.8 所示。
表 8.8 exit()系统调用
参数 含义
功能
使进程主动终止
调用格式
void exit(int status);
返回值
status 是要传递给父进程的一个整数，用于向父进程通报进程运行的
结果状态。status 的含义通常是：0 表示正常终止；非 0 表示运行有
错，异常终止
（3）等待与收集进程
在并发执行的环境中，父子进程的运行速度是无法确定的。但在许多情况下，我们希
望父子进程的进展能够有某种同步关系。比如，父进程需要等待子进程的运行结果才能继
续执行下一步计算，或父进程要负责子进程的回收工作，它必须在子进程结束后才能退出。
这时就需要通过 wait()系统调用来阻塞父进程，等待子进程结束。
当父进程调用 wait()时，自己立即被阻塞，由 wait()检查是否有僵尸子进程。如果找到
就收集它的信息，然后撤掉它的 PCB；否则就阻塞下去，等待子进程发来终止信号。父进
程被信号唤醒后，执行 wait()，处理子进程的回收工作。经 wait()收集后，子进程才真正的
消失。
wait ()系统调用含义如表 8.9 所示。
表 8.9 wait ()系统调用
参数 含义
功能
阻塞进程直到子进程结束；收集子进程
调用格式
int wait(int *statloc);
返回值
>0：子进程的 PID。
－1：调用失败。
0：其他。
*statloc 保存了子进程的一些状态。如果是正常退出，则其末字
节为 0，第 2 字节为退出状态；如果是非正常退出(即被某个信号所终
止)，则其末字节不为 0，末字节的低 7 位为导致进程终止的信号的信
号值。若不关心子进程是如何终止的，可以用 NULL 作参数，即
wait(NULL)
图 8.11 描述了用 wait()系统调用等待子进程的流程。
图 8.11 wait 实现进程的等待
3. 进程的阻塞与唤醒
运行中的进程，若需要等待一个特定事件的发生而不能继续运行下去时，则主动放弃
CPU。等待的事件可能是一段时间、从文件中读出的数据、来自键盘的输入、某个资源被
释放或是某个硬件产生的事件等。进程通过调用内核函数来阻塞自己，将自己加入到一个
等待队列中。阻塞操作的步骤是：建立一个等待队列的节点，填入本进程的信息，将它链
入指定的等待队列中；将进程的状态置为睡眠态；调用进程调度函数选择其他进程运行，
并将本进程从可执行队列中删除。
当等待的事件发生时，引发事件的相关程序会调用内核函数来唤醒等待队列中的满足
等待条件的进程。例如，当磁盘数据到来后，文件系统要负责唤醒等待这批文件数据的进
程。唤醒操作的处理是：将进程的状态改变为可执行态并加到可执行队列中。如果此进程
的优先级高于当前正在运行的进程的优先级，则会触发进程调度函数重新进行进程调度。
当该进程被调度执行时，它调用内核函数把自己从等待队列中删除。
另外，信号也可以唤醒处于可中断睡眠态的进程。被信号唤醒为伪唤醒，即唤醒不是
因为等待的事件发生。被信号伪唤醒的进程在处理完信号后通常会再次睡眠。
8.3.3 Shell 命令的执行过程
Shell 程序的功能就是执行 Shell 命令，执行命令的主要方式是创建一个子进程，让这
个子进程来执行命令的映像文件。因此，Shell 进程是所有在其下执行的命令的父进程。图
8.12 所示是 Shell 执行命令的大致过程，从中可以看到一个进程从诞生到消失的整个过程。
图 8.12 Shell 命令的执行过程
Shell 进程初始化完成后，在屏幕上显示命令提示符，等待命令行输入。接收到一个命
令行后，Shell 对其进行解析，确定要执行的命令及其选项和参数，以及命令的执行方式，
然后创建一个子 Shell 进程。
子进程诞生后立即更换进程映像为要执行的命令的映像文件，运行该命令直至结束。
如果命令行后面没有带后台运行符“&”，则子进程在前台开始运行。此时，Shell 阻塞自
己，等待命令执行结束。如果命令行后面带有“&”符，则子进程在后台开始运行，同时
Shell 也继续执行下去。它立即显示命令提示符，接受下一个命令。命令子进程执行结束后，
向父进程 Shell 进程发送信号，由 Shell 对子进程进行回收处理。
8.4 进程调度
在多任务系统中，进程调度是 CPU 管理的一项核心工作。根据调度模式的不同，多任
务系统有两种类型，即非抢占式和抢占式。非抢占模式是由正在运行的进程自己主动放弃
CPU，这是早期多任务系统的调度模式。现代操作系统大多采用抢占式模式，即由调度程
序决定什么时候停止一个进程的运行，切换其他进程运行。对于抢占式多任务系统来说，
进程调度是系统设计中最为关键的一个环节。
8.4.1 进程调度的基本原理
1. 进程调度的功能
进程调度的功能是按照一定的策略把 CPU 分配给就绪进程，使它们轮流地使用 CPU
运行。进程调度实现了进程就绪态与运行态之间的转换。调度工作包括：
(1) 当正运行的进程因某种原因放弃 CPU 时，为该进程保留现场信息。
(2) 按一定的调度算法，从就绪进程中选一个进程，把 CPU 分配给它。
(3) 为被选中的进程恢复现场，使其运行。
2. 进程调度算法
进程调度算法是系统效率的关键，它确定了系统对资源，特别是对 CPU 资源的分配策
略，因而直接决定着系统最本质的性能指标，如响应速度、吞吐量等。进程调度算法的目
标首先是要充分发挥 CPU 的处理能力，满足进程对 CPU 的需求。此外还要尽量做到公平
对待每个进程，使它们都能得到运行机会。
常用的调度算法有：
(1) 先进先出法：按照进程在就绪队列中的先后次序来调度。这是最简单的调度法，
但缺点是对一些紧迫任务的响应时间过长。
(2) 短进程优先法：优先调度短进程运行，以提高系统的吞吐量，但对长进程不利。
(3) 时间片轮转法：进程按规定的时间片轮流使用 CPU。这种方法可满足分时系统对
用户响应时间的要求，有很好的公平性。时间片长度的选择应适当，过短会引起频繁的进
程调度，过长则对用户的响应较慢。
(4) 优先级调度法：为每个进程设置优先级，调度时优先选择优先级高的进程运行，
使紧迫的任务可以优先得到处理。更为细致的调度法又将优先级分为静态优先级和动态优
先级。静态优先级是预先指定的，动态优先级则随进程运行时间的长短而降低或升高。两
种优先级组合调度，既可以保证对高优先级进程的响应，也不致过度忽略低优先级的进程。
实际应用中，经常是多种策略结合使用。如时间片轮转法中也可适当考虑优先级因素，
对于紧急的进程可以分配一个长一些的时间片，或连续运行多个时间片等。
8.4.2 Linux 系统的进程调度
Linux 系统采用的调度算法简洁而高效。尤其是 2.5 版后的内核采用了新的调度算法，
在高负载和多 CPU 并行系统中执行得极为出色。
1. 进程的调度信息
在 Linux 系统中，进程的 PCB 中记录了与进程调度相关的信息，主要有：
(1) 调度策略(policy)：对进程的调度算法。决定了调度程序应如何调度该进程。Linux
系统将进程分为实时进程与普通(非实时)进程两类，分别采用不同的调度策略。实时进程
是那些对响应时间要求很高的进程，如视频与音频应用、过程控制和数据采集等，系统优
先响应它们对 CPU 的要求；对普通进程则采用优先级+时间片轮转的调度策略，以兼顾系
统的响应速度、公平性和整体效率。
(2) 实时优先级(rt_priority)：实时进程的优先级，标志实时进程优先权的高低，取值范
围为 1(最高)～99(最低)。
(3) 静态优先级(static_prio)：进程的基本优先级。进程在创建之初被赋予了一个表示优
先程度的“nice 数”，它决定了进程的静态优先级。静态优先级的取值范围为 100(最高)～
139(最低)，它是计算时间片的依据。
(4) 动态优先级(prio)：普通进程的实际优先级。它是对静态优先级的调整，随进程的
运行状况而变化，取值范围为 100(最高)～139(最低)。
(5) 时间片(time_slice)：进程当前剩余的时间片。时间片的初始大小取决于进程的静态
优先级，优先级越高则时间片越长。而后，随着进程的运行，时间片不断减少。时间片减
为 0 的进程将不会被调度，直到它再次获得新的时间片。
进程的调度策略和优先级等是在进程创建时从父进程那里继承来的，不过用户可以通
过系统调用改变它们。setpriority()和 nice()用于设置静态优先级；sched_setparam()用于设置
实时优先级；sched_setscheduler()用于设置调度策略和参数。
2. 调度函数和队列
Linux 系统中用于实现进程调度的程序是内核函数 schedule()。该函数的功能是按照预
定的策略在可执行进程中选择一个进程，切换 CPU 现场使之运行。
调度程序中最基本的数据结构是可执行队列 runqueue。每个 CPU 都有一个自己的可执
行队列，它包含了所有等待该 CPU 的可执行进程。runqueue 结构中设有一个 curr 指针，指
向正在使用 CPU 的进程。进程切换时，curr 指针也跟着变化。
旧版本的调度程序(2.4 版内核)在选择进程时需要遍历整个可执行队列，用的时间随进
程数量的增加而增加，最坏时可能达到 O(n)复杂度级别。新内核(2.6 版内核)改进了调度的
算法和数据结构，使算法的复杂度达到 O(1)级(最优级别)，故称为 O(1)算法。
新内核的 runqueue 队列结构中实际包含了多个进程队列，它们将进程按优先级划分，
相同优先级的链接在一起，成为一个优先级队列。所有优先级队列的头地址都记录在一个
优先级数组中，按优先级顺序排列。实时进程的优先级队列在前(1～99)，普通进程的优先
级队列在后(100～139)。当进程调度选择进程时，只需在优先级数组中选择当前最高优先
级队列中的第 1 个进程即可。无论进程的多少，这个操作总可以在固定的时间内完成，因
而是 O(1)级别的。可执行队列的结构如图 8.13 所示。
图 8.13 可执行队列的结构示意图
影响调度算法效率的另一个操作是为进程重新计算时间片。旧算法中，当所有进程的
时间片用完后，调度程序遍历可执行队列，逐个为它们重新赋予时间片，然后开始下一轮
的执行。当进程数目很多时，这个过程会十分耗时。为克服这个弊端，新调度函数将每个
优先级队列分为两个：活动队列和过期队列。活动队列包含了那些时间片未用完的进程，
过期队列包含了那些时间片用完的进程。相应地，在 runqueue 中设置了两个优先级数组，
一个是活动数组 active，它记录了所有活动队列的指针；另一个是过期数组 expired，它记
录了所有过期队列的指针。当一个进程进入可执行态时，它被按照优先级放入一个活动队
列中；当进程的时间片耗完时，它会被赋予新的时间片并转移到相应的过期队列中。当所
有活动队列都为空时，只需将 active 和 expired 数组的指针互换，过期队列就成为活动队列。
这个操作也是 O(1)级别的。
可以看出，新调度的实现策略是用复杂的数据结构来换取算法的高效率的。
3. Linux 的进程调度策略
进程调度在选择进程时，首先在可执行队列中寻找优先级最高的进程。由于实时进程
的优先级(1～99)总是高于普通进程(100～139)，所以实时进程永远优先于普通进程。选中
进程后，根据 PCB 中 policy 的值确定该进程的调度策略来进行调度。在 schedule()函数中
实现了 3 种调度策略，即先进先出法，时间片轮转法和普通调度法。
（1）先进先出法
先进先出(FIFO，First In First Out)调度算法用于实时进程，采用 FIFO 策略的实时进程
就绪后，按照优先级 rt_priority 加入到相应的活动队列的队尾。调度程序按优先级依次调度
各个进程运行，具有相同优先级的进程采用 FIFO 算法。投入运行的进程将一直运行，直
到进入僵死态、睡眠态或者是被具有更高实时优先级的进程夺去 CPU。
FIFO 算法实现简单，但在一些特殊情况下有欠公平。比如，一个运行时间很短的进程
排在了一个运行时间很长的进程之后，它可能要花费比运行时间长很多倍的时间来等待。
（2）时间片轮转法
时间片轮转(RR，Round Robin)算法也是用于实时进程，它的基本思想是给每个实时进
程分配一个时间片，然后按照它们的优先级 rt_priority 加入到相应的活动队列中。调度程序
按优先级依次调度，具有相同优先级的进程采用轮换法，每次运行一个时间片。时间片的
长短取决于其静态优先级 static_prio。当一个进程的时间片用完，它就要让出 CPU，重新
计算时间片后加入到同一活动队列的队尾，等待下一次运行。RR 算法也采用了优先级策略。
在进程的运行过程中，如果有更高优先级的实时进程就绪，则调度程序就会中止当前进程
而去响应高优先级的进程。
相比 FIFO 来说，RR 算法在追求响应速度的同时还兼顾到公平性。
（3）普通调度法
普通调度法(NORMAL，Normal Scheduling)用于普通进程的调度。每个进程拥有一个
静态优先级和一个动态优先级。动态优先级是基于静态优先级调整得到的实际优先级，它
与进程的平均睡眠时间有关，进程睡眠的时间越长则其动态优先级越高。调整优先级的目
的是为了提高对交互式进程的响应性。
NORMAL 算法与 RR 算法类似，都是采用优先级+时间片轮转的调度方法。进程按其
优先级 prio 被链入相应的活动队列中。调度程序按优先级顺序依次调度各个队列中的进程，
每次运行一个时间片。一个进程的时间片用完后，内核重新计算它的动态优先级和时间片，
然后将它加入到相应的过期队列中。与 RR 算法的不同之处在于，普通进程的时间片用完
后被转入过期队列中，它要等到所有活动队列中的进程都运行完后才会获得下一轮执行机
会。而 RR 算法的进程始终在活动队列中，直到其执行完毕。这保证了实时进程不会被比
它的优先级低的进程打断。可以看出，RR 算法注重优先级顺序，只在每级内采用轮转；而
NORMAL 算法注重的是轮转，在每轮中采用优先级顺序。
4. 进程调度的时机
当需要切换进程时，进程调度程序就会被调用。引发进程调度的时机有下面几种：
(1) 当前进程将转入睡眠态或僵死态。
(2) 一个更高优先级的进程加入到可执行队列中。
(3) 当前进程的时间片用完。
(4) 进程从核心态返回到用户态。
从本质上看，这些情况可以归结为两类时机，一是进程本身自动放弃 CPU 而引发的调
度，这是上述第 1 种情况。这时的进程是主动退出 CPU，转入睡眠或僵死态。二是进程由
核心态转入用户态时发生调度，包括上述后 3 种情况。这类调度发生最为频繁。当进程执
行系统调用或中断处理后返回，都是由核心态转入用户态。时间片用完是由系统的时钟中
断引起的中断处理过程，而新进程加入可执行队列也是由内核模块处理的，因此也都会在
处理完后从内核态返回到用户态。
Linux 系统是抢占式多任务系统，上述情况除了第 1 种是进程主动调用调度程序放弃
CPU 的，其他情况下都是由系统强制进行重新调度的，这就是 CPU 抢占(preemption)。在
必要时抢占 CPU 可以保证系统具有很好的响应性。为了标志何时需要重新进行进程调度，
系统在进程的 PCB 中设置了一个 need_resched 标志位，为 1 时表示需要重新调度。当某个
进程的时间片耗尽，或有高优先级进程加入到可执行队列中，或进程从系统调用或中断处
理中返回前，都会设置这个标志。每当系统从核心态返回用户态时，内核都会检查
need_resched 标志，如果已被设置，内核将调用调度函数进行重新调度。
8.5 进程的互斥与同步
多个进程在同一系统中并发执行，共享系统资源，因此它们不是孤立存在的，而是会
互相影响或互相合作。为保证进程不因竞争资源而导致错误的执行结果，需要通过某种手
段实现相互制约。这种手段就是进程的互斥与同步。
8.5.1 进程的互 进程的互 斥与同步
并发进程彼此间会产生相互制约的关系。进程之间的制约关系有两种方式：一是进程
的同步，即相关进程为协作完成同一任务而引起的直接制约关系；二是进程的互斥，即进
程间因竞争系统资源而引起的间接制约关系。
1. 临界资源与临界区
临界资源(critical resource)是一次仅允许一个进程使用的资源。例如，共享的打印机就
是一种临界资源。当一个进程在打印时，其他进程必须等待，否则会使各进程的输出混在
一起。共享内存、缓冲区、共享的数据结构或文件等都属于临界资源。
临界区(critical region)是程序中访问临界资源的程序片段。划分临界区的目的是为了明
确进程的互斥点。当进程运行在临界区之外时，不会引发竞争条件。而当进程运行在临界
区内时，它正在访问临界资源，此时应阻止其他进程进入同一资源的临界区。
例 8.3: 在前面章节中描述了一个选修课中选课计数器的例子。当 A、B 两个进程同时
修改计数器 D 时就会发生更新错误，因此 D 是一个临界资源，而程序 A 和 B 中访问 D 的
程序段就称为临界区，如图 8.14 所示。
图 8.14 临界资源与临界区
2. 进程的互斥与同步
因共享临界资源而发生错误，其原因在于多个进程访问该资源的操作穿插进行。要避
免这种错误，关键是要用某种方式来阻止多个进程同时访问临界资源，这就是互斥。
进程的互斥(mutex)就是禁止多个进程同时进入各自的访问同一临界资源的临界区，以
保证对临界资源的排它性使用。以未选课计数器为例，当进程 A 运行在它的(A 的)临界区
内时，进程 B 不能进入它的(B 的)临界区执行，进程 B 必须等待，直到 A 离开 A 的临界区
后，B 才可进入 B 的临界区运行。
进程的同步(synchronization)是指进程间为合作完成一个任务而互相等待、协调运行步
调。例如：两个进程合作处理一批数据，进程 A 先对一部分数据进行某种预处理，然后通
过缓冲区传给进程 B 做进一步的处理。这个过程要循环多次直至全部数据处理完毕。
访问缓冲区是一个典型的进程同步问题。缓冲区是两进程共享的临界资源，当一个进
程存取缓冲区时，另一个进程是不能同时访问的。但两进程之间并不仅仅是简单的互斥关
系，它们还要以正确的顺序来访问缓冲区，即必须 A 进程写缓冲区在前，B 进程读缓冲区
在后，且读与写操作必须一一交替，不能出现连续多次地读或写操作。比如，当 A 进程写
满缓冲区后，即使 B 进程因某种原因还没有占用缓冲区，A 也不能去占用缓冲区再次写数
据，它必须等待 B 将缓冲区读空后才能再次写入。
可以看出，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。广义地讲，互斥
与同步实际上都是一种同步机制。
8.5.2 信号量与 P 、V 操作
实现进程互斥与同步的手段有多种，其中，信号量是最早出现的进程同步机制。因其
简洁有效，信号量被广泛地用来解决各种互斥与同步问题。
1. 信号量与 P 、V 操作
信号量(semaphore)是一个整型变量 s，它为某个临界资源而设置，表示该资源的可用数
目。s 大于 0 时表示有资源可用，s 的值就是资源的可用数；s 小于或等于 0 时表示资源已
都被占用，s 的绝对值就是正在等待此资源的进程数。
信号量是一种特殊的变量，它仅能被两个标准的原语操作来访问和修改。这两个原语
操作分别称为 P 操作和 V 操作。
P(s)操作定义为：s=s-1; if (s<0) block(s);
V(s)操作定义为：s=s+1; if (s<=0) wakeup(s);
P、V 操作是原语，也就是说其执行过程是原子的，不可分割的。P、V 操作中用到两
个进程控制操作，其中，block(s)操作将进程变换为等待状态，放入等待 s 资源的队列中。
wakeup(s)操作将 s 的等待队列中的进程唤醒，将其放入就绪队列。这两种操作后都会调用
schedule()函数，引发一次进程调度。
P(s)操作用于申请资源 s。P(s)操作使资源的可用数减 1。如果此时 s 是负数，表示资源
不可用(即已被别的进程占用)，则该进程等待。如果此时 s 是 0 或正数，表示资源可用，则
该进程进入临界区运行，使用该资源。
V(s)操作用于释放资源 s。V(s)操作使资源的可用数加 1。如果此时 s 是负数或 0，表示
有进程在等待此资源，则用信号唤醒等待的进程。如果此时 s 是正数，表示没有进程在等
待此资源，则无须进行唤醒操作。
使用信号量与 P、V 操作可以正确实现进程间的各种互斥与同步。信号量的作用类似
于人行道上的红绿灯：行人过街时先按下按钮(执行 P 操作)，车行道上的红灯亮起，来往
车辆见到信号即停止；行人过街后，按另一个按钮(执行 V 操作)，使绿灯亮起，车辆放行。
2. 用 P 、V 操作实现进程互斥
例 8.4:设进程 A 和进程 B 都要访问临界资源 C，为实现互斥访问，需要为临界资源 C
设置一个信号量 s，初值为 1。当进程运行到临界区开始处时，先要做 P(s)操作，申请资源
s。当进程运行到临界区结束处时，要做 V(s)操作，释放资源 s。进程 A 和进程 B 执行过程
如图 8.15 所示。
图 8.15 P、V 操作实现进程的互斥
由于 s 的初值是 1，当一个进程执行 P(s)进入临界区后，s 的值变为 0。此时若另一个
进程执行到 P(s)操作时就会被挂起(s 的值变为－1)，从而阻止了其进入临界区执行。当一
个进程退出其临界区时执行 V(s)操作，若此时 s=1 表示没有进程在等待此资源，若此时 s=0
表示有一个进程在等待此资源，系统将唤醒该进程，使之可以进入临界区运行。这样就保
证了两个进程总是互斥地访问临界资源。
3. 用 P、V 操作实现进程同步
设两进程为协作完成某一项工作，需要共享一个缓冲区。先是一个进程 C 往缓冲区中
写数据，然后另一个进程 D 从缓冲区中读取数据，如此循环直至处理完毕。缓冲区属于临
界资源，为使这两个进程能够协调步调，串行地访问缓冲区，需用 P、V 操作来同步两进
程。这种工作模式称为“生产者-消费者模式”。同步的方法介绍如下。
例 8.5:设置两个信号量：
“缓冲区满”信号量 s1，s1=1 时表示缓冲区已满，s1=0 时表示缓冲区未满。初值为 0。
“缓冲区空”信号量 s2，s2=1 时表示缓冲区已空，s2=0 时表示缓冲区未空。初值为 1。
进程 C 和进程 D 执行过程如图 8.16 所示。
图 8.16 P、V 操作实现进程的同步
由于 s1 的初值是 0，s2 的初值是 1，最初进程 C 执行 P(s2)可以进入临界区，向缓冲区
写入，而进程 D 在执行 P(s1)时就会被挂起，因此保证了先写后读的顺序。此后，两者的同
步过程是：当 C 写满缓冲区后，执行 V(s1)操作，使 D 得以进入它的临界区进行读缓冲区
操作。在 D 读缓冲区时，C 无法写下一批数据，因为再次执行 P(s2)时将阻止它进入临界区。
当 D 读空缓冲区后，执行 V(s2)操作，使 C 得以进入它的临界区进行写缓冲区操作。在 C
写缓冲区时，D 无法读下一批数据，因为再次执行 P(s1)时将阻止它进入临界区。这样就保
证了两个进程总是互相等待，串行访问缓冲区。访问的顺序只能是“写、读、写、读、……”，
而不会出现“读、写、读、写、……”或“读、读、写、……”、“写、写、读、……”
之类的错误顺序。
8.5.3 Linux 的信号量机制
在 Linux 系统中存在两种信号量的实现机制，一种是针对系统的临界资源设置的，由
内核使用的信号量；另一种是供用户进程使用的。
内核管理着整个系统的资源，其中许多系统资源都属于临界资源，包括核心的数据结
构、文件、设备、缓冲区等。为防止对这些资源的竞争导致错误，在内核中为它们分别设
立了信号量。内核将信号量定义为一种结构类型 semaphore，其中包含了 3 个数据域：该资
源的可用数 count、等待该资源的进程数 sleepers 以及该资源的等待队列的地址 wait。内核
同时还提供了操作这种类型的信号量的两个函数 down()和 up()，分别对应于 P 操作和 V 操
作。当内核访问系统资源时，通过这两个函数进行互斥与同步。
用户进程在使用系统资源时是通过调用内核函数来实现的，这些内核函数的运行由内
核信号量进行同步。因而，用户程序不必考虑有关针对系统资源的互斥与同步问题。但如
果是用户自己定义的某种临界资源，如前面例子中的停车场计数器，则不能使用内核的信
号量机制。这是因为内核的信号量机制只是在内核内部使用，并未向用户提供系统调用接
口。
为了解决用户进程级上的互斥与同步问题，Linux 以进程通信的方式提供了一种信号量
机制，它具有内核信号量所具有的一切特性。用于实现进程间信号量通信的系统调用有：
semget()，用于创建信号量；semop()，用于操作信号量，如 P、V 操作等；semctl()，用于
控制信号量，如初始化等。用户进程可以通过这几个系统调用对自定义临界资源的访问进
行互斥与同步。
8.5.4 死锁问题
死锁(deadlock)是指系统中若干个进程相互“无知地”等待对方所占有的资源而无限地
处于等待状态的一种僵持局面，其现像是若干个进程均停顿不前，且无法自行恢复。
死锁是并发进程因相互制约不当而造成的最严重的后果，是并发系统的潜在的隐患。
一旦发生死锁，通常采取的措施是强制地撤销一个或几个进程，释放它们占用的资源。这
些进程将前功尽弃，因而死锁是对系统资源极大的浪费。
死锁的根本原因是系统资源有限，而多个并发进程因竞争资源而相互制约。相互制约
的进程需要彼此等待，在极端情况下，就可能出现死锁。图 8.17 所示是可能引发死锁的一
种运行情况。
A、B 两进程在运行过程中都要使用到两个临界资源，假设资源 1 为独占设备磁带机，
资源 2 为独占设备打印机。若两个进程执行时在时间点上是错开的，则不会发生任何问题。
但如果不巧在时序上出现这样一种情形：进程 A 在执行完 P(s1)操作后进入资源 1 的临界区
运行，但还未执行到 P(s2)操作时发生了进程切换，进程 B 开始运行。进程 B 执行完 P(s2)
操作后进入资源 2 的临界区运行，在运行到 P(s1)操作时将被挂起，转入等待态等待资源 1。
当再度调度到进程 A 运行时，它运行到 P(s2)操作时也被挂起，等待资源 2。此时两个进程
彼此需要对方的资源，却不放弃各自占有的资源，因而无限地被封锁，陷入死锁状态。
图 8.17 资源竞争导致潜在的死锁可能
分析死锁的原因，可以归纳出产生死锁的 4 个必要条件，即：
(1) 资源的独占使用：资源由占有者独占，不允许其他进程同时使用。
(2) 资源的非抢占式分配：资源一旦分配就不能被剥夺，直到占用者使用完毕释放。
(3) 对资源的保持和请求：进程因请求资源而被阻塞时，对已经占有资源保持不放。
(4) 对资源的循环等待：每个进程已占用一些资源，而又等待别的进程释放资源。
上例中，磁带机和打印机都是独占资源，不可同时共享，具备了条件 1；资源由进程
保持，直到它用 V 操作主动释放资源，具备了条件 2；进程 A 在请求资源 2 被阻塞时，对
资源 1 还未释放，进程 B 也是如此，具备了条件 3；两个进程在已占据一个资源时，又在
相互等待对方的资源，这形成了条件 4。所有这些因素凑到一起就导致了死锁的发生。
解决死锁的方案就是破坏死锁产生的必要条件之一，方法有：
(1) 预防：对资源的用法进行适当的限制。
(2) 检测：在系统运行中随时检测死锁的条件，并设法避开。
(3) 恢复：死锁发生时,设法以最小的代价退出死锁状态。
预防是指采取某种策略，改变资源的分配和控制方式，使死锁的条件无法产生。但这
种做法会导致系统的资源也无法得到充分的利用。检测是指对资源使用情况进行监视，遇
到有可能引发死锁的情况就采取措施避开。这种方法需要大量的系统开销，通常以降低系
统的运行效率为代价。因此，一般系统都采取恢复的方法，就是在死锁发生后，检测死锁
发生的位置和原因，用外力撤销一个或几个进程，或重新分配资源，使系统从死锁状态中
恢复过来。
每个系统都潜在地存在死锁的可能，Unix/Linux 系统也不例外。但是，出于对系统效
率的考虑，Unix/Linux 系统对待死锁采取的是“鸵鸟算法”，即系统并不去检测和解除死
锁，而是忽略它。这是因为对付死锁的成本过高，而死锁发生的概率过低(大约连续开机半
年才会出现一次)。如果采用死锁预防或者检测算法会严重降低系统的效率。
8.6 进程通信
进程间为实现相互制约和合作需要彼此传递信息。然而每个进程都只在自己独立的存
储空间中运行，无法直接访问其他进程的空间。因此，当进程需要交换数据时，必须采用
某种特定的手段，这就是进程通信。进程通信(Inter-Process Communication，IPC)是指进程
间采用某种方式互相传递信息，少则是一个数值，多则是一大批字节数据。
为实现互斥与合作，进程使用信号量相互制约，这实际上就是一种进程通信，即进程
利用对信号量的 P、V 操作，间接地传递资源使用状态的信息。更广泛地讲，进程通信是
指在某些有关联的进程之间进行的信息传递或数据交换。这些具有通信能力的进程不再是
孤立地运行，而是协同工作，共同实现更加复杂的并发处理。
8.6.1 进程通信的方式
进程间的通信有多种方式，大致可以分为信号量、信号、管道、消息和共享内存几类。
从通信的功能来分，进程通信方式可以分为低级通信和高级通信两类。低级通信只是
传递少量的数据，用于通知对方某个事件；高级通信则可以用来在进程之间传递大量的信
息。低级通信的方式有信号量和信号，高级通信的方式有消息、管道和共享内存等。
按通信的同步方式来分，进程通信又分为同步通信与异步通信两类。同步通信是指通
信双方进程共同参与整个通信过程，步调协调地发送和接收数据。这就像是打电话，双方
必须同时在线，同步地交谈。异步通信则不同，通信双方的联系比较松散，通信的发送方
不必考虑对方的状态，发送完就继续运行；接收方也不关心发送方的状态，在自己适合的
时候接收数据。异步通信方式就如同发送电子邮件，不必关心对方何时接收。管道和共享
内存等都属于同步通信，而信号、消息则属于异步通信。
现代操作系统一般都提供了多种通信机制，以满足各种应用需要。利用这些机制，用
户可以方便地进行并发程序设计，实现多进程之间的相互协调和合作。
Linux 系统支持以下几种 IPC 机制：
(1) 信号量(semaphore)：作为一种 IPC 机制，信号量用于传递进程对资源的占有状态
信息，从而实现进程的同步与互斥。
(2) 信号(signal)：信号是进程间可互相发送的控制信息，一般只是几个字节的数据，
用于通知进程有某个事件发生。信号属于低级进程通信，传递的信息量小，但它是 Linux
进程天生具有的一种通信能力，即每个进程都具有接收信号和处理信号的能力。系统通过
一组预定义的信号来控制进程的活动，用户也可以定义自己的信号来通告进程某个约定事
件的发生。
(3) 管道(pipe)：管道是连接两个进程的一个数据传输通路，一个进程向管道写数据，
另一个进程从管道读数据，实现两进程之间同步传递字节流。管道的信息传输量大，速度
快，内置同步机制，使用简单。
(4) 消息队列(message queue)：消息是结构化的数据，消息队列是由消息链接而成的链
式队列。进程之间通过消息队列来传递消息，有写权限的进程可以向队列中添加消息，有
读权限的进程则可以读走队列中的消息。与管道不同的是，这是一种异步的通信方式：消
息的发送方把消息送入消息队列中，然后继续运行；接收进程在合适的时机去消息队列中
读取自己的消息。相比信号来说，消息队列传递的信息量更大，能够传递格式化的数据。
更主要的是，消息通信是异步的，适合于在异步运行的进程间交换信息。
(5) 共享内存(shared-memory)：共享内存通信方式就是在内存中开辟一段存储空间，将
这个区域映射到多个进程的地址空间中，使得多个进程能够共享这个内存区域。通信双方
直接读/写这个存储区即可达到数据共享的目的。由于进程访问共享内存区就如同访问进程
自己的地址空间，因此访问速度最快，只要发送进程将数据写入共享内存，接收进程就可
立即得到数据。共享内存的效率在所有 IPC 中是最高的，特别适用于传递大量的、实时的
数据。但它没有内置的同步机制，需要配合使用信号量实现进程的同步。因此，较之管道，
共享内存的使用较复杂。
本节将只介绍 Linux 的信号和管道这两种通信机制的概念与实现原理。对于 Linux 系
统的使用者来说，了解这两种进程通信方式可以更好地理解系统的运行机制。而对于并发
软件的开发者来说，还应该进一步地学习和掌握其他几种通信方式。
8.6.2 Linux 信号通信原理
信号是 Unix 系统中最古老的 IPC 机制之一，主要用于在进程之间传递控制信号。信号
属于低级通信，任何一个进程都具有信号通信的能力。
1. 信号的概念
信号是一组正整数常量，进程之间通过传送信号来通信，通知进程发生了某事件。例
如，当用户按下 Ctrl＋c 键时，当前进程就会收到一个信号，通知它结束运行。子进程在结
束时也会用信号通知父进程。
i386 平台的 Linux 系统共定义了 32 个信号(还有 32 个扩展信号)，如图 8.18 所示。
[root@localhost ~]#kill -l
常用的信号见表 8.10。
图 8.18 63 个信号量
表 8.10 Linux 常用的信号定义
信号值 信号名 用途 默认处理
1
SIGHUP 终端挂断信号 终止处理
2
SIGINT 来自键盘（Ctrl+c）的终止信号 终止运行
3
SIGQUIT 来自键盘（Ctrl+\）的终止信号 终止运行并转储
8
SIGFPE 浮点异常信号，表示发生了致命的运算错误 终止运行并转储
9
SIGKILL 立即结束运行信号，杀死进程 终止运行
14
SIGALRM 时钟定时信息 终止运行
15
SIGTERM 结束运行信号，命令进程主动终止 终止运行
17
SIGCHLD 子进程结束信号 忽略
18
SIGCONT 恢复运行信号，使暂停的进程继续运行 断续运行
19
SIGSTOP 暂停执行信号，通常来调试程序 停止运行
20
SIGTSTP 来自键盘（Ctrl+z）的暂停信号 停止运行
2. 信号的产生与发送
信号可以由某个进程发出，也可以由键盘中断产生，还可以由 kill 命令发出。进程在
某些系统错误情况下也会有信号产生。
信号可以发给一个或多个进程。进程 PCB 中含有几个用于信号通信的域，用于记录进
程收到的信号以及各信号的处理方法。发送信号就是把一个信号送到目标进程的 PCB 的信
号域上。如果目标进程正在睡眠(可中断睡眠态)，内核将唤醒它。
终端用户用 kill 命令或键盘组合按键向进程发送信号，程序则是直接使用 kill()系统调
用向进程发送信号。
kill 命令含义如表 8.11 所示。
表 8.11 kill 命令
参数 含义
功能
向一个进程发信号，常用于终止进程的运行
调用格式
kill [选项] 进程号
选项
-s 向进程发 s 信号。S 可以是信号值或信号名。常用的终止进程运行
的信号为：15（SIGTERM）、2（SIGINT）、9（SIGKILL）。如没
指定－s 选项，则默认发信号 15。
例 8.6：kill 命令用法示例
编写一个简单 test1 程序，用来试验一个普通进行（未对信号处理作特殊设置的进程）
对信号的默认反应。
（1）编写源文件，如图 8.19 所示。
[root@localhost ~]# cat >> test.c
#include<stdio.h>
main()
{ printf(“test text!\n”);
}
可以用 Ctrl+c 退出
图 8.18 源 test.c
（2）编译生成可执行文件 test1。如图 8.19 所示。
[root@localhost ~]#gcc –o test1 test.c
[root@localhost ~]#ls
图 8.19 成可执行文件 test1
（3）运行 test1(前台后台)，显示进程运行情况，如图 8.20 所示。
通过后台运行./test1&，shell 显示出该进程的 PID 是[1]或 25768。在用 ps 查看进程运
行情况，显示有 3 个进程正在运行：bash、ps 和 test1（其中 test1 的 PID 用[1]显示）。
[root@localhost ~]#./test1
[root@localhost ~]#./test1&
ps
图 8.20 前台后台运行
（4）终止进程 test1 运行。如图 8.21 所示。
用 kill 终止 test1，并查看现有运行进程，此时 test1 已中止运行。
[root@localhost ~]#kill 1
[root@localhost ~]#ps
图 8.21 终止进程 test1 运行
（5）终止进程 bash 运行。如图 8.21 所示。
[root@localhost ~]#kill -9 25501
此时，25501 号进程是本终端的 shell 进程，它忽略 SIGTERM 信号，用 SIGKILL 信号
才可杀死，但这将导致终端窗口被关闭。因此，使用 kill -9 命令杀系统进程时应慎重。
3. 信号的检测与处理
当一个进程要进入或退出睡眠状态时，或即将从核心态返回用户态时，都要检查是否
有信号到达。若有信号到达，则转去执行与该信号相对应的处理程序。
进程可以选择忽略或阻塞这些信号中的绝大部分，但有两个信号除外，这就是引起进
程暂停执行的 SIGSTOP 信号和引起进程终止的 SIGKILL 信号。至于其他信号，进程可以
选择处理它们的具体方式。对信号的处理方式分为以下 4 种
(1) 忽略：收到的信号是一个可忽略的信号，不做任何处理；
(2) 阻塞：阻塞对信号的处理；
(3) 默认处理：调用内核的默认处理函数；
(4) 自行处理：执行进程自己的信号处理程序。
8.6.3 Linux 管道通信原理
管道是 Linux 系统中一种常用的 IPC 机制。管道可以看成是连接两个进程的一条通信
信道。利用管道，一个进程的输出可以成为另一个进程的输入，因此可以在进程间快速传
递大量字节流数据。
管道通信具有以下特点：
(1) 管道是单向的，数据只能向一个方向流动。需要双向通信时，需要建立起两个管
道；
(2) 管道的容量是有限的(一个内存页面大小)；
(3) 管道所传送的是无格式字节流，使用管道的双方必须事先约定好数据的格式。
管道是通过文件系统来实现的。Linux 将管道看做是一种特殊类型的文件，而实际上它
是一个以虚拟文件的形式实现的高速缓冲区。管道文件建立后由两个进程共享，其中一个
进程写管道，另一个进程读管道，从而实现信息的单向传递。读/写管道的进程之间的同步
由系统负责。
终端用户在命令行中使用管道符“|”时，Shell 会为管道符前后的两个命令的进程建立
起一个管道。前面的进程写管道，后面的进程读管道。用户程序中可以使用 pipe()系统调用
来建立管道，而读/写管道的操作与读/写文件的操作完全一样。
8.7 线程
在传统的操作系统中，一直将进程作为能独立运行的基本单位。20 世纪 80 年代中期，
Microsoft 公司最先提出了比进程更小的基本运行单位——线程。线程的引入提高了系统并
发执行的程度，因而得到广泛的应用。现代操作系统中大都支持线程，应用软件也普遍地
采用了多线程设计，使系统和应用软件的性能进一步提高。
8.7.1 线程的概念
多道处理系统中，进程是系统调度和资源分配的基本单位，每一次切换进程，系统都
要做保护和恢复现场的工作。因此，切换进程的过程要耗费相当多的系统资源和 CPU 时间。
为了减少并发程序的切换时间，提高整个系统的并发效率，引入了线程的概念。
传统的进程中，每个进程中只存在一条控制线索。进程内的各个操作步是顺序执行的。
现代操作系统提供了对单个进程中多条控制线索的支持。这些控制线索被称为线程
(threads)。线程是构成进程的可独立运行的单元。一个进程由一个或多个线程构成，并以线
程作为调度实体，占有 CPU 运行。线程可以看做是进程内的一个执行流，一个进程中的所
有线程共享进程所拥有的资源，分别按照不同的路径执行。例如，一个 Word 进程中包含
了多个线程，当一个线程处理编辑时，另一个线程可能正在做文件备份，还有一个线程正
在发送邮件。网络下载软件通常也含有多个线程，每个线程负责一路下载，多路下载都在
独立地、并发地向前推进。这些多线程的软件虽然只是一个进程，却表现出内在的并发执
行的特征，效率明显提高。
8.7.2 线程和进程的区别
进程和线程都是用来描述程序的运行活动的。它们都是动态实体，有自己的状态，整
个生命周期都在不同的状态之间转换。它们之间的不同表现在以下几个方面：
进程是操作系统资源分配的基本单位，每一个进程都有自己独立的地址空间和各种系
统资源，如打开的文件、设备等；线程基本上不拥有自己的资源，只拥有一点在运行中必
不可少的资源(如程序记数器、寄存器和栈)。它与同一进程中的其他线程共享该进程的资
源。在创建和撤销进程时系统都要进行资源分配和回收工作，而创建和撤销线程的系统开
销要小得多。
进程调度时，系统需要保存和切换整个 CPU 运行环境的现场信息，这要消耗一定的存
储资源和 CPU 时间；线程共享进程的资源，线程调度是在进程内部切换，只需保存少量的
寄存器，不涉及现场切换操作，因而切换速度很快。因此，对于切换频繁的工作，多线程
设计方式比多进程设计方式可以提供更高的响应速度。
此外，由于多个线程共享同一进程的资源，因而线程之间相互通信更容易；而进程间
通信一般必须要通过系统提供的进程间通信机制。
8.7.3 内核级线程与用户级线程
线程有“用户级线程”与“内核级线程”之分。所谓用户级线程，是指不需要内核支
持而在用户程序中实现的线程，对线程的管理和调度完全由用户程序完成。内核级线程则
是由内核支持的线程，由内核完成对线程的管理和调度工作。尽管这两种方案都可实现多
线程运行，但它们在性能等方面相差很大，可以说各有优缺点。
在调度方面，用户级线程的切换速度比核心级线程要快得多。但如果有一个用户线程
被阻塞，则核心将整个进程置为等待态，使该进程的其他线程也失去运行的机会。核心级
线程则没有这样的问题，即当一个线程被阻塞时，其他线程仍可被调度运行。
在实现方面，要支持内核级线程，操作系统内核需要设置描述线程的数据结构，提供
独立的线程管理方案和专门的线程调度程序，这些都增加了内核的复杂性。而用户线程不
需要额外的内核开销，内核的实现相对简单得多，同时还节省了系统进行线程管理的时间
开销。
8.7.4 Linux 中的线程
Linux 实现线程的机制属于用户级线程。 从内核的角度来说，并没有线程这个概念。
Linux 内核把线程当作进程来对待。内核没有特别定义的数据结构来表达线程，也没有特别
的调度算法来调度线程。每个线程都用一个 PCB(task_struct)来描述。所以，在内核看来，
线程就像普通的进程一样，只不过是该进程和其他一些进程共享地址空间等资源。Linux
称这样的不独立拥有的进程为“轻量级进程（Light Weight Process，LWP）”以轻量级进
程的方式来实现线程，既省去了内核级线程的复杂性，又避免了用户级线程的阻塞问题。
在 Linux 中实现多现线应用的策略是：为每个线程创建一个 LWP 进程，线程的调度由
内核（进程高度程序）完成，线程的管理在核外函数库中实现。开发多线程应用的函数库
是 pthread 线程库，它提供了一组完备的函数来实现线程的创建、终止和同步等操作。
创建 LWP 进程的方式与创建普通进程类似，只不过是秀 clone()系统调用来完成的。
与 fork（）的区别是，clone()允许在调用进多传递一些参数标志来指明需要共享的资源。
父进程用创建 LWP 子进程的共享资源。一个进程的所有线程构成一上线程组，其中第一个
创建的线程是领头线程，领头线程的 PID 就作为该线程组的组标识号 TGID。线程组中的
成员具有紧密的关系，它们工作在同一应用数据集上，相互协作，独立完成各自的任务。
由于具有进程的属性，每个线程都是被独立地高度的，一个线程阻塞不会影响其它线程，
由于具有轻量级的属性，线程之间的切换速度很快，使得整个应用能顺利地并发执行。
例 8.7: 启动 firefox 浏览器，查看它的线程组。
[root@localhost ~]#ps –eLf | grep firefox
运行结果如图 8.22
图 8.22 启动 firefox 浏览器
输出的第 2、3、4 列分别是 TGID、PPID 和 PID。结果显示：25983 号进程创建了一
个 25997 线程，25997 又创建了 26002、26003、26004 等十几个线程，其中 26004 号线程
是领头线程，它的标识号是 26002 就是成 firefox 线程组的标识号。它们执行的程序都是
firefox。
8. 8 习题
1．什么是进程？为什么要引入进程概念？
2.进程的基本特征是什么？它与程序的主要区别是什么？
3.简述进程的基本状态以及进程状态的转换。
4.进程控制块的作用是什么？它通常包括哪些内容？
5.进程控制的功能是什么？Linux 创建进程的方式有何特点？
6.进程调度的功能是什么？Linux 采用了哪些进程调度策略？
7.Linux 的进程调度发生在什么情况下？
8．并发进程间的制约有哪几种？引起制约的原因是什么？
9.什么是临界资源和临界区？什么是进程的互斥和同步？
10.什么是死锁？产生死锁的原因和必要条件是什么？
11.进程间有哪些通信方式？它们各有什么特点？
12.什么是线程？说明线程与进程的区别与联系。



第 九 章 存储 管理
程序在运行前必须先调入内存存放。对于多道程序并发的系统来说，内存中同时要容
纳多个程序，然后，计算机的内存资源是有限的，这就需要通过合理的管理机制来满足各
进程对内存的需求。存储管理的任务是合理地管理系统的内存资源，使多个进程能够在限
的物理存储空间共存，安全并高效地运行。
9.1 存储管理概述
操作系统中用于管理内存空间的模块称为内存管理模块，它负责内存的全部管理工作，
具体地说就是要完成 4 个功能，即存储空间的分配、存储地址的变换、存储空间的保护以
及存储空间的扩充。
9.1.1 内存的分 内存的分配与回收 配与回收
内存分配是为进入系统准备运行的程序分配内存空间，内存回收是当程序运行结束后
回收其所占用的内存空间。为实现此功能，系统须跟踪并记录所有内存空间的使用情况，
按照一定的算法为进程分配和回收内存空间。
存储分配方案主要包括以下要素：
(1) 描述存储分配的数据结构：系统需采用某种数据结构(表格、链表或队列等)来登记
当前内存使用情况以及空闲区的分布情况，供存储分配程序使用。在每次分配或回收操作
后，系统都要相应地修改这些数据结构以反映这次分配或回收的结果。
(2) 实施分配的策略：确定内存分配和回收的算法。好的算法应既能满足进程的运行
要求，又能充分利用内存空间。
分配策略及相关数据结构的设计直接决定存储空间的利用率以及存储分配的效率，因
而对系统的整体性能有很大的影响。
9.1.2 地址变换
由于用户在编写程序时无法预先确定程序在内存中的具体位置，所以只能采用逻辑地
址进行编程。而当程序进入内存后，必须把程序中的逻辑地址转换为程序所在的实际内存
地址。这一转换过程称为存储空间的地址变换，或称为地址映射。地址变换是由内存管理
模块与硬件的地址变换机构共同完成的。
1. 地址的概念
（1）符号地址
在用高级语言编写的源程序中，我们使用符号名(变量名、函数名、语句标号等)来表
示操作对象或控制的转移地址。比如用变量名代表一个存储单元、用函数名代表函数的入
口地址、用语句标号代表跳转地址等。这些符号名的集合称为符号名空间。因此，高级语
言程序使用的地址空间是符号名空间，编程者不需考虑程序代码和数据的具体存放地址。
例 9.1:，以下所示的是一个 C 源程序的片段：
main()
{ int i=1;
…
i++;
…
}
此源程序中没有具体地址，只有符号名。这里 main 代表的是程序的入口地址，i 代表
的是一个数据的存放地址。
（2）逻辑地址
编译程序将源代码中的语句逐条翻译为机器指令，为每个变量分配存储单元，并用存
储单元的地址替换变量名。这些指令和数据顺序存放在一起，从 0 开始编排地址，形成目
标代码。目标代码所占有的地址范围称为逻辑地址空间，范围是 0～n-1，n 为目标代码的
长度。逻辑地址空间中的地址称为逻辑地址，或称为相对地址。在访问内存的指令中用逻
辑地址来指定一个操作数的地址，在跳转指令中用逻辑地址来表示要跳转到的那条指令的
地址。
例 9.2:，对上例所示的源程序进行编译，生成的目标代码的反汇编结果如下：
00000000: …
…
0000004B: LDS R24,0x0060 ;从 0060 地址取数据，加载到 R24 寄存器
0000004D: ADIW R24,0x01 ;R24 寄存器内容加 1
0000004E: STS 0x0060,R24 ;将 R24 寄存器内容写回 0060 地址
…
00000060: 0x0001 ;i 变量的存储单元
…
左侧列出的是指令和数据的逻辑地址，从 0 地址开始顺序排列。i 变量被分配到逻辑地
址 0060 处，i++语句被译为 LDS、ADIW 和 STS 3 条指令，它们排在逻辑地址 004B、004D
和 004E 处。在目标代码的指令中已看不到符号名了，而代之以具体的地址值。如 LDS 和
STS 指令的操作数地址是 0060，表示要到这个地址(也就是 i 变量)读/写数据。
（3）物理地址
物理内存由一系列的内存单元组成，这些存储单元从 0 开始按字节编址，称为内存地
址。当目标程序加载到内存中时，它所占据的实际内存空间就是它的物理存储空间，物理
空间中的地址称为物理地址，或称为绝对地址。
每次程序加载时所获得的实际地址空间取决于系统当时的运行状态，因而是不确定的。
但物理地址空间不会是从 0 开始的，因为系统内存的低端地址通常被操作系统占用。由此
可看出，程序的逻辑地址空间与物理地址空间是不同的。由于编译程序无法预知程序执行
时的实际内存地址，所以目标程序中的地址都是从 0 开始的逻辑地址，而实际地址只有在
程序加载时才能得知。
假设上面例子的程序加载到内存，它分配到的内存地址空间是从 1024(即十六进制的
0x0400)开始的，则程序中各条指令和变量的地址是原来的相对地址加上 1024 这个基址。
因此程序在内存的起始地址为 0x0400，LDS、ADIW 和 STS 3 条指令的绝对地址分别为
0x044B、0x044D 和 0x044E，i 变量的绝对地址为 0x0460。
图 9.1 所示是关于内存地址的示意图。仍以前面的程序为例，源程序中的 i 变量是用符
号名 i 标识的一个存储单元，它没有具体的地址值。i++语句的操作就是对这个存储单元进
行的操作。编译时，编译程序为 i 分配了具体的存储单元，并用该单元的编号地址 96(0x0060)
替换掉所有 i 符号名。程序在加载时获得实际的内存空间。如果得到的内存空间的起始地
址是 1024，则程序中的相对地址 96 单元就是实际内存的 1120(0x0460)单元。
图 9.1 内存地址概念
2. 地址变换
用户编程时只能使用逻辑地址，而 CPU 执行指令时必须指定物理地址，因此必须在指
令执行前进行地址变换，将指令中的逻辑地址转换为 CPU 可直接寻址的物理地址，这样才
能保证 CPU 访问到正确的存储单元。
假设上面的例子程序加载到内存，它分配到的内存地址空间是从 1024 开始的，则程序
中各条指令和变量的地址都是原来的相对地址加上 1024。为了适应这个变化，指令中引用
的操作数地址也应进行相应的调整。下面所示是经过地址变换后的目标代码，粗体部分为
变换后的操作数的绝对地址。
00000400: …
…
0000044B: LDS R24,0x0460 ;从 0460 地址取数据，加载到 R24 寄存器
0000044D: ADIW R24,0x01 ;R24 寄存器内容加 1
0000044E: STS 0x0460,R24 ;将 R24 寄存器内容写回 0460 地址
…
00000460: 0x0001 ;i 变量的存储单元
…
9.1.3 内存的保护
内存保护的含义是要确保每个进程都在自己的地址空间中运行，互不干扰，尤其是不
允许用户进程访问操作系统的存储区域。对于允许多个进程共享的内存区域，每个进程也
只能按自己的权限(只读或读/写)进行访问，不允许超越权限进行访问。
许多程序错误都会导致地址越界，比如使用了未赋值的“野”指针或空指针等。还有
一些程序代码则属于恶意的破坏。存储保护的目的是为了防止因为各种原因导致的程序越
界和越权行为。为此，系统必须设置内存保护机制，对每条指令所访问的地址进行检查。
一旦发现非法的内存访问就会中断程序的运行，由操作系统进行干预。现代操作系统都具
有良好的存储保护功能，因此程序错误通常只会导致程序的异常结束，而不会造成系统的
崩溃。
常用的存储保护措施有：
(1) 界限保护：在 CPU 中设置界限寄存器，限制进程的活动空间。
(2) 保护键：为共享内存区设置一个读/写保护键，在 CPU 中设置保护键开关，它表示
进程的读/写权限。只有进程的开关代码和内存区的保护键匹配时方可进行访问。
(3) 保护模式：将 CPU 的工作模式分为用户态与核心态。核心态下的进程可以访问整
个内存地址空间，而用户态下的进程只能访问在界限寄存器所规定范围内的空间。
9.1.4 内存的扩充
尽管内存容量不断提高，但相比应用规模的增长来说，内存总是不够的。因此，内存
扩充始终是存储管理的一个重要功能。
“扩充”存储器空间的基本思想是借用外存空间来扩展内存空间，方法是让程序的部
分代码进入内存，其余驻留在外存，在需要时再调入内存。主要的实现方法有以下 3 种：
1. 覆盖技术
覆盖(overlay)技术的原理是将一个程序划分为几个模块。程序的必要模块(主控或常用
功能)常驻内存，其余模块共享一个或几个存储空间。它们平时驻留在外存中，在需要时才
装入内存，覆盖掉某个暂时不用的模块。
覆盖技术的缺点是必须在编程时对程序进行模块划分，并确定程序模块之间的覆盖关
系。这无疑增加了编程的复杂度。
2. 交换技术
在多个程序并发执行时，往往有一些程序因等待某事件而暂时不能运行。如果将暂时
不能执行的程序换到外存中，就可以获得空闲内存空间来运行别的程序。这就是交换
(swapping)技术的思想。与覆盖技术不同的是，交换是以进程为单位进行的。
交换技术的优点是增加了可并发运行的程序数目，且对用户的程序结构没有要求。其
缺点是对整个进程进行的换入、换出操作往往需要花费大量的 CPU 时间。
3. 虚拟存储器
以上两种存储扩充技术都不能称为虚拟存储技术，因为在用户(编程者)眼里看到的还
是实际大小的内存。虚拟存储(virtual memory)的原理是只将程序的部分代码调入内存，其
余驻留在外存空间中，在需要时调入内存。程序代码的换入和换出完全由系统动态地完成，
用户察觉不到。因此，用户看到的是一个比实际内存大得多的“虚拟内存”。
虚拟存储技术的特点是方便用户编程，存储扩充的性能也是最好的。关于虚拟存储器
请参考后面章节。
9.2 存储管理方案
随着操作系统的发展，内存管理技术也在不断地发展着。本节将简要介绍各种存储管
理方案的技术和特点。
9.2.1 分区存储管理
多道程序系统的出现要求内存中能同时容纳多个程序，分区管理方案因而诞生。分区
分配是多道程序系统最早使用的一种管理方式，其思想是将内存划分为若干个分区，操作
系统占用其中一个分区，其他分区由用户程序使用，每个分区容纳一个用户程序。
1. 分区分配策略
最初的分区划分方法是固定分区，即系统把内存静态地划分为若干个固定大小的分区。
当一个进程被建立时，系统按其程序的大小为其分配一个足够大的分区。由于分区大小是
预先划分好的，通常会大于程序的实际尺寸，因此分区内余下的空闲空间就被浪费掉了。
图 9.2(a)所示为固定分区的内存分配方式。
对固定分区分配策略进行改进就产生了可变分区分配。它的思想是：在程序调入内存
时，按其实际大小动态地划分分区。这种量体裁衣的分配方式避免了分区内空间的浪——
设最初进入内存的是进程 1（64KB）、进程 2（160KB）和进程 3（224 KB），系统为它
们分配了合适的空间，如图 9.2(b)所示。
分区分配的主要问题是存储“碎片”。碎片(fragment)是无法被利用的空闲存储空间。
固定分区存在“内部碎片”问题，即遍布在各个分区内的零碎剩余空间。可变分区存在“外
部碎片”问题，即随着进程不断地进入和退出系统，一段时间后，内存中的空闲分区会变
得支离破碎，这些碎片空间的总和可能足够大，但因为不连续，所以不能被利用。图 9.2
（c）描述了外部碎片的产生过程。
例 9.3:在前面 3 个进程运行一段时间后，进程 2 运行结束退出，进程 4 进入内存，它
的大小是 64KB；又一段时间后，进程 1 运行结束退出，进程 5 进入内存，它的大小是 54KB。
当一个新的 300 KB 的进程 6 想要进入系统运行时，内存中的空闲空间的总数虽然足够，但
因为是碎片，所以系统暂时无法接纳这个作业。
解决外部碎片问题的一个有效方法是存储紧缩技术。存储紧缩(compaction)的思想是采
用动态地址变换，使程序在内存中可以移动。当内存出现碎片现象时，系统将暂停所有进
程的运行，将各个进程的分区向内存一端移动，从而将碎片合并成一个连续的存储空间。
紧缩完成后，程序继续运行。例如，图 9.2(c)紧缩后的结果如图 9.2(d)所示。这种采用可变
分区+存储紧缩技术的存储管理方案称为可重定向分区管理，在早期的操作系统中曾普遍应
用。
图 9.2 分区分配及存储变化图
2． ． 动态地址变换过程
简单分区采用静态地址变换方式，程序装入内存后就不能再移动了。因为程序移动后，
指令和数据的存放地址变了，而指令中的操作数地址却没有相对地变化，导致指令不能正
确地寻址。为了使程序在内存中可以移动，就必须采用动态地址变换。可重定位分区的动
态地址变换过程如图 9.3 所示。
图 9.3 可重定位分区的地址变换过程
CPU 中设置了一对表示程序存储空间界限的寄存器，长度寄存器中存放的是程序的长
度，基址寄存器中存放的是程序所占内存空间的起始地址。每个进程的 PCB 中都有一对相
应的寄存器值，当进程得到 CPU 准备运行时，现场恢复操作会将这两个值装入寄存器中。
当 CPU 取到一条指令时，硬件地址变换机构将逻辑地址与基址寄存器内容相加就可得到实
际内存地址。
每次存储紧缩完成后，系统根据程序的新位置更新各个进程的基址值。这样，当程序
重新运行时，CPU 将按新的基址来做地址转换，程序的运行不会受到任何影响。
3． ． 分区的保护与扩充
进程只能在自己的分区内活动。存储保护的方式是上下界地址保护，即进程运行时，
它的空间上下界地址被加载到 CPU 的界限(或基址/长度)寄存器中。如果进程试图访问超越
分区上下界的地址，则会引起地址越界中断，使进程结束。
在分区管理中，用户程序的大小受可用分区大小的限制。可以使用覆盖或交换技术来
实现内存扩充。
总的来说，分区管理的特点是简单、支持多道程序，但有碎片问题。可重定位分区管
理提供了解决碎片问题的一种途径，因而提高了存储空间的利用率。但存储紧缩比较耗时，
在进行存储紧缩时，所有用户进程都要停止运行，系统为此付出的代价过大。
9.2.2 页式存储管理
产生碎片问题的根源在于程序要求连续的存储空间，而解决这一问题的根本措施就是
突破这一限制，使程序代码可以分散地存放在不同的存储空间中。分散存储使得内存中每
一个空闲的区域都可以被程序利用，这就是页式存储分配的基本思想。
1． ． 分页的概念
分页(paging)的概念是：将程序的逻辑地址空间分成若干大小相等的片段，称为页面
(page)，用 0、1、2…序号表示；同时，把内存空间也按同样大小分为若干区域，称为块，
或页帧(page frame)，也用 0、1、2…序号表示。
经过分页后，程序的逻辑地址可看成由两部分组成，即页号+页内位移。对 X86 体系
结构来说，逻辑地址为 32 位，页面大小为 4KB，则逻辑地址的高 20 位为页号，低 12 位为
页内位移，如图 9.4 所示。例如，有一个逻辑地址为十六进制 0001527A，则其页号为十六
进制 0X15，页内位移为十六进制 0X27A。
页号 页内位移
31 12 11
图 9.4 页式存储的逻辑地址结构
2. 页式分配思想
页式分配的思想是以页为单位为程序分配内存，每个内存块装一页。一个进程的映像
的各个页面可分散存放在不相邻的内存块中，用页表记录页号与内存块号之间的映射关系。
图 9.5 描述了这种分配方式。
页表是进程的一个重要资源，它记录了进程的页面与块号的对应关系。
例 9.4:在图 9.5 中，进程 A 的程序代码被划分为 4 页，分别加载到内存的第 10、11、4
和 6 块中，进程 B 的程序代码被划分为 3 页，分别加载到内存的第 8、9 和 12 块中，它们
的页表如图 9.5 所示。虽然它们都不是连续存放的，但通过页表可以得到分散的各块的逻
辑顺序。
图 9.5 页式分配示意图
3. 页面的分配与释放
系统设有一个内存块表，记录系统内所有物理内存块的分配和使用状况。内存块表可
采用位示图的方式或空闲块链表方式表示。位示图用一系列的二进制位来描述各个内存块
的状态，每个位对应一个内存块，0 表示空闲，1 表示占用。空闲链是用拉链的方式来组织
空闲的内存块的。系统根据内存块表进行存储分配和释放，每次分配和释放操作后都要相
应地修改此表。
不考虑虚拟存储技术时，页式的分配和释放算法都比较简单。当进程建立时，系统根
据进程映像的大小查找内存块表，若有足够的空闲块则为进程分配块，为其建立页表并将
页表信息填入 PCB 中。若没有足够的空闲块，则拒绝进程装入。进程结束时，系统将进程
占用的内存块回收，并撤销进程的页表。
4. 页式地址变换
页式系统采用动态地址变换方式，通过页表进行地址变换。每个进程有一个页表。用
逻辑地址的页号查找页表中对应的表项即可获得该页表所在的内存的块号。页表通常存放
在内存中，页表的长度和内存地址等信息记录在进程的 PCB 中。另外，在 CPU 中设有一
个页表寄存器，用来存放正在执行的进程的页表长度和内存地址。当进程进入 CPU 执行时，
进程的页表信息被填入页表寄存器，CPU 根据页表寄存器的值即可找到该进程的页表。
当 CPU 执行到一条需要访问内存的指令时，指令操作数的逻辑地址被装入逻辑地址寄
存器，分页地址转换机构会自动地进行地址转换，形成实际的内存地址。CPU 随后对此地
址进行访问操作。地址转换的过程是：将逻辑地址按位分成页号和页内位移两部分，再以
页号为索引去检索页表，得到该页号对应的物理块号。将页内位移作为块内位移与块号拼
接即得到实际的内存地址。图 9.6 描述了这一地址变换过程。
图 9.6 页式地址变换过程
例 9.5:设系统的页面大小为 8 KB，CPU 的当前指令要访问的逻辑地址为 20744，则该
地址对应的页号为 2（20744/8k 的商，1K=1024)，页内位移为 4360(20744/8k 的余数)。经
查页表后，页号 2 变换为块号 3，块内位移为 4360 拼接，得到实际地址为 28936(3*8k+4360)。
页表存储在内存中。CPU 为了访问一个内存单元需要两次访问内存，第一次是查页表，
第二次完成对内存单元的读/写操作。这显然降低了带有访问内存操作的指令的执行速度。
为缩短查页表的时间，系统通常使用快表技术，就是将一些常用的页表表项保存在 CPU 内
部的高速缓存中。存在高速缓存中的页表称为快表，快表的访问速度比内存页表的访问速
度要高得多。当进行地址转换时，先用页号去查快表，查到则直接进行地址转换，未查到
时则去内存查页表，再进行地址转换，同时将此页对应的页表项登记到快表中。
9.2.3 段式存储管理
在分区和页式存储管理中，程序的地址空间是一维连续的。然而，从用户的观点来看，
一维的程序结构有时并不理想。比如，按模块化设计准则，一个应用程序通常划分为一个
主模块、若干个子模块和数据模块等。划分模块的好处是可以分别编写和编译源程序，并
且可以实现代码共享、动态链接等编程技术。段式存储分配就是为了适应用户对程序结构
的需求而设计的存储管理方案。
1. 段的概念
在段式存储管理系统中，程序的地址空间由若干个大小不等的段组成。段(segment)是
逻辑上完整的信息单位，划分段的依据是信息的逻辑完整性以及共享和保护等需要。分段
后，程序的逻辑地址空间是一个二维空间，其逻辑地址由段号和段内位移两部分组成。
分段与分页的区别在于：段是信息的逻辑单位，长度不固定，由用户进行划分；页是
信息的物理单位，长度固定，由系统进行划分，用户不可见。另外，页式的地址空间是一
维的，段式的地址空间是二维的。
2. 段式分配思想
段式分配策略是以段为单位分配内存，每个段分配一个连续的分区。段与段间可以不
相邻接，用段表描述进程的各段在内存中的存储位置。段表中包括段长和段起始地址等信
息。图 9.7 描述了段式存储的分配方式。
图 9.7 段式分配示意图
3. 段的分配与释放
段式分配对内存空间的管理类似于可重定位分区的管理方法。当进程建立时，系统为
进程的各段分配一个连续的存储区，并为它建立段表。进程结束后，系统回收段所占用的
分区，并撤销段表。进程在运行过程中也可以动态地请求分配或释放某个段。
4. 段式地址变换
当进程开始执行时，进程的段表信息被填入 CPU 中的段表寄存器。根据段表寄存器的
值，CPU 可以找到该进程的段表。当 CPU 执行到一条要访问某逻辑地址的指令时，以逻辑
地址中的段号为索引去检索段表，得到该段在内存的起始地址，与逻辑地址中的段内位移
相加就可得到实际的内存地址。图 9.8 描述了这一地址变换过程。
例 9.6:设 CPU 的当前指令要访问的逻辑地址为 2 段的 210 位移处。经查段表后，获得
2 段的起始地址为 6200，将其与段内位移 210 相加，得到实际地址为 6410。
图 9.8 段式地址变换过程
5. 段式存储的共享、保护与扩充
段式存储允许以段为单位的存储共享。段的共享就是内存中只保留该段的一个副本，
供多个进程使用。当进程需要共享内存中的某段程序或数据时，只要在进程的段表中填入
共享段的信息，并置以适当的读/写控制权，就可以访问该段了。
当 CPU 访问某逻辑地址时，硬件自动把段号与段表长度进行比较，同时还要将段内地
址与段表中该段长度进行比较，如果访问地址合法则进行地址转换，否则产生地址越界中
断信号。对共享段还要检验进程的访问权限，权限匹配则可进行访问，否则产生读/写保护
中断。
段式存储空间的扩充采用段式虚拟存储器技术，在此不作介绍。
段式管理的特点是便于程序模块化处理，可以充分实现分段共享和保护。但由于段需
要连续存储，可能出现碎片问题。另外，段式管理需要硬件具备段式地址变换机构。
9.2.4 段页式存储管理
段页式存储管理是页式和段式两种存储管理方案相结合的产物。它的分配思想是段式
划分，页式存储。即把程序的各段按页式分配方式存储在内存的块中，每段一个页表。另
设一个段表，指示各段的页表位置。这样就实现了程序的不连续存放。
采用段页式方式时，程序的逻辑地址可以看做是由 3 部分组成的，即段号+页号+页内
地址。地址变换过程是：先根据段号查段表，获得该段的页表，再用页号查页表，得到实
际内存块号，最后与页内地址合并即可得到实际内存地址。
段页式存储管理具备了页式和段式两种存储管理方式的优点，存储空间的利用率高，
并能满足各种应用要求。但这种管理技术过于复杂，软硬件开销也很大，因此较少使用。
9.3 虚拟存储管理
9.3.1 虚拟存储技术
1. 程序的局部性原理
实验证明，在进程的执行过程中，CPU 不是随机访问整个程序或数据范围的，而是在
一个时间段中只集中地访问程序或数据的某一个部分。进程的这种访问特性称为局部性
(locality)原理。局部性原理表明，在进程运行的每个较短的时间段中，进程的地址空间中
只有部分空间是活动的(即被 CPU 访问的)，其余的空间则处于不活动的状态。这些不活动
的代码可能在较长的时间内不会被用到(比如初始化和结束处理)，甚至在整个运行期间都
可能不会被用到(比如出错处理)。它们完全可以不在内存中驻留，只当被用到时再调入内
存，这就是虚拟存储器的思想。可以说，程序的局部性使虚拟存储成为可能。
2. 虚拟存储器原理
虚拟存储器的原理是用外存模拟内存，实现内存空间的扩充。做法是：在外存开辟一
个存储空间，称为交换区。进程启动时，只有部分程序代码进入内存，其余驻留在外存交
换区中，在需要时调入内存。
与覆盖技术的不同之处在于，覆盖是用户有意识地进行的，用户所看到的地址空间还
是实际大小的空间；而在虚拟存储技术中，内存与交换空间之间的交换完全由系统动态地
完成，应用程序并不会察觉，因而应用程序看到的是一个比实际内存大得多的“虚拟内存”。
与交换技术的不同之处在于，交换是对整个进程进行的，进程映像的大小仍要受实际
内存的限制；而在虚拟存储中，进程的逻辑地址空间可以超越实际内存容量的限制。因此，
虚拟存储管理是实现内存扩展的最有效的手段。
不过，读/写硬盘的速度比读/写内存要慢得多，因此访问虚拟存储器的速度比访问真正
内存的速度要慢，所以这是一个以时间换取空间的技术。另外，虚拟空间的容量也是有限
制的。一般来说，虚拟存储器的容量是实际内存容量与外存交换空间容量之和，这与具体
的系统设置有关。但虚存容量最终要受地址寄存器位数的限制。对于 32 位计算机来说，32
位可以表示的数字范围是 4 G，因此它的虚存空间的上限就是 4 GB。
3. 虚拟存储器的实现技术
虚拟存储器的实现技术主要有页式虚存和段式虚存两种，以页式虚存最为常用。本节
将只介绍这种页式虚存技术。
9.3.2 页式虚拟存储器原理
页式虚拟存储器的思想就是在页式存储管理基础上加入以页为单位的内外存空间的交
换来实现存储空间扩充功能。这种存储管理方案称为请求页式存储管理。
1. 请求页式管理
在请求页式管理系统中，最初只将过程映像的若干页面调入内存，其余的页面保存在
外存的交换区中。当程序运行中访问的页面不在内存时，则产生缺页中断。系统响应此中
断，将缺页从外存交换区中调入内存。
请求页式的页表中除了内存块号外还增加了一些信息字段，设置这些信息是为了实施
页面的管理和调度，如地址变换、缺页处理、页面淘汰以及页面保护等。实际系统的页表
结构会有所不同，这取决于系统的页面管理和调度策略。图 9.9 所示是一种典型的请求页
式的页表结构。其中，“状态位”表示该页当前是否在内存；“修改位”表示该页装入内
存后是否被修改过；“访问位”表示该页最近是否被访问过；“权限位”表示进程对此页
的读/写权限；“外存地址”为该页面在外存交换区中的存储地址。
图 9.9 请求页式页表
2. 地址变换过程
请求页式的地址变换过程增加了对缺页故障的检测。当要访问的页面对应的页表项的
状态位为 N 时，硬件地址变换机构会立即产生一个缺页中断信号。CPU 响应此中断后，将
原进程阻塞，转去执行中断处理程序。缺页中断的处理程序负责将缺页调入内存，并相应
地修改进程的页表。中断返回后，原进程就可以重新进行地址变换，继续运行下去了。
例 9.7:图 9.10 所示是一个地址变换过程的实例，设系统的页面大小为 4 KB，CPU 的当
前指令要访问的逻辑地址为 0x3080，则该地址对应的页号为 3，页内位移为 0x80。设进程
当前的页表为图中左面的页表。由于 3 号页面当前不在内存，故引起缺页中断，进程被阻
塞。CPU 开始执行缺页中断处理程序，调度页面。中断处理的结果是 2 号页面被淘汰，3
号页面被调入，覆盖了 2 号页面。修改后的页表为图中右面的页表。中断返回后原进程被
唤醒，进入就绪状态。当再次运行时，重新执行上次那条指令，并成功地将逻辑地址 0x3080
变换为 0x9080。
图 9.10 请求页式地址变换过程举例
3. 缺页中断的处理
缺页中断后，CPU 暂停原进程的运行，转去执行缺页中断的处理程序。缺页中断处理
程序的任务是将进程请求的页面调入内存。它先查到该页在外存的位置，如果内存中还有
空闲块则将缺页直接调入。如果没有空闲块就需要选择淘汰一个已在内存的页面，再将缺
页调入，覆盖被淘汰的页面。在覆盖被淘汰的页面前，先检查该页在内存驻留期间是否曾
被修改过(页表中的修改位为 1)。如果被修改过，则要将其写回外存交换空间，以保持内外
存数据的一致性。缺页调入后，还要相应地修改进程页表和系统的内存分配表。中断处理
完成后，原进程从等待状态中被唤醒，进入就绪状态，准备重新运行。图 9.11 描述了缺页
中断的处理过程。
图 9.11 缺页中断处理
4. 页面淘汰 算法
在缺页中断处理中，页面淘汰算法对系统的性能来说至关重要。如果淘汰算法不当，
系统有时会产生“抖动(thrashing)”现象，即刚调出的页很快又被访问到，马上又被调入。
抖动的系统处于频繁的页交换状态，CPU 的大量时间都花在处理缺页中断上，故系统效率
大幅度降低。
理论上讲，最优的算法应是淘汰以后不再访问或很久以后才会访问的页面，然而最优
的算法是无法确定的。实际常用的是估计的方法，即优先淘汰那些估计最近不太可能被用
到的页面。常用页面淘汰算法有以下 3 种：
（1）先进先出法(First-In First-Out，FIFO)
FIFO 算法的思想是优先淘汰最先进入内存的页面，即在内存中驻留时间最久的页面。
不过在有些时候，页面调入的先后并不能反映页面的使用情况。最先进入内存执行的代码
可能也是最常用到的，比如程序的主控部分。因此，FIFO 算法性能比较差，通常还要附加
其他的判断来优化此算法。
FIFO 算法的实现比较简单，只要用一个队列记录页面进入内存的先后顺序，淘汰时选
择队头的页面即可。
（2）最近最少使用法(Least Recently Used，LRU)
LRU 算法不是简单地以页面进入内存的先后顺序为依据，而是根据页面调入内存后的
使用情况进行决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作
为“最近的将来”的近似。因此，LRU 算法选择淘汰在最近期间最久未被访问的页面予以
淘汰。
LRU 算法有多种实现和变种，其基本思想是在页表中设置一个访问字段，记录页面在
最近时间段内被访问的次数或自上次访问以来所经历的时间，当须淘汰一个页面时，选择
现有页面中访问时间值最早的予以淘汰。
实际运用证明 LRU 算法的性能相当好，它产生的缺页中断次数已很接近理想算法。但
LRU 算法实现起来不太容易，需要增加硬件或软件的开销。与之相比，FIFO 算法性能尽
管不是最好，却更容易实现。
（3）最少使用频率法(Least Frequently Used，LFU)
LFU 算法是 LRU 的一个近似算法。它选择淘汰最近时期使用频率最少的页面。实现时
需要为每个页面设置一个访问记数器(也可以用移位寄存器实现)，用来记录该页面被访问
的频率，需要淘汰页面时，选择记数值最小的页面淘汰。
应当指出的是，无论哪种算法都不可能完全避免抖动发生。产生抖动的原因一是页面
调度不当，另一个就是实际内存过小。对系统来说应当尽量优化淘汰算法，减少抖动发生；
而对用户来说，加大物理内存是解决抖动的最有效方法。
总的来说，请求页式存储管理实现了虚拟存储器，因而可以容纳更大或更多的进程，
提高了系统的整体性能。但是，空间性能的提升是以牺牲时间性能为代价的，过度扩展有
可能产生抖动，应权衡考虑。一般来说，外存交换空间为实际内存空间的 1～2 倍比较合适。
9.4 Linux 的存储管理
9.4.1 X86 架构的内存访问机制
1. x86 的内在寻址模式
x86 32 位系统使用 32 根地址线，可寻址空间达 4 GB。因此，启用了物理地址扩展 PAE
后，使用 36 根地址线，可寻址空是为 64GB。本章只对未启用 PAE 的传统 x86－32 系统架
构进行讲解。
x86 使用的是段式管理机制，在段式管理的基础上还可以选择启用页式管理机制。当
CPU 中的控制寄存器 CR0 的 PG 位为 1 时启用分页机制，为 0 则不启用。运行 Linux 系统
需要启动分页机制。
x86 的地址分为 3 种：逻辑地址、线性地址和物理地址。逻辑地址也称为虚拟地址，
是机器指令中使用的地址。由 x86 采用段式管理，所以它的逻辑地址是二维的，由段和段
内位移表示。线性地址是逻辑地址经过 x86 分段机构处理后得到的一维地址。物理地址是
线性地址经过页式变换得到的实际内存地址，这个地址将被送到地址总线上，定位实际要
访问的内存单元。
实现地址变换的硬件是 CPU 中的内存管理单元（Memory Management Unit,MMU），
当 CPU 执行到一条需要访问内存的指令时，CPU 的执行单元（Execution Unit，EU）会发
出一个虚拟地址。这个虚拟地址被 MMU 截获，经过段式和页式变换后将其转为物理地址。
2. x86 的 的 段式 地址变换
x86 系统的内存空间被按类划分为若干的段，包括代码段、数据段、栈段等。每个段
由一个段描述符来描述。段描述符中记录了该段的基址、长度和访问权限等属性。各段的
段描述符连续存入，形成段描述符表（GDT 和 LDT）。
在 CPU 执行单元中设有几个段寄存器，其中存放的是段描述符的索引项。主要的段寄
存器是 cs、ds 和 ss，分别用于检索代码段、数据段和栈段的段描述符。地址变换过程是：
根据指令类型确定其对应的段（如跳转类指令用 cs 段，读写类指令用 ds 段等），再通过
对应的段寄存器在段描述符表中选出段描述符。将指令给出的地址作为偏移值，对照段描
述符进行越界和越权检查；检查通过后，将偏移值与段描述符中的段基址相加，形成线性
地址。
3. x86 的分页地址变换
x86 系统的页面大小为 4KB。页表项中除页帧外还包含了一些标志位，描述页的属性
一。主要的标志位有“存在位 P”（Present）、“读写位 R/W”（Read/Write）、“访问位
A”（Accessed）和“修改位 D”（Dirty）。系统能够识别这些标志位并根据访问情况做出
反应，例如，读一个页后会设置它的 A 位；写一个页后会设置他的 D 位；访问一个 P 位为
0 的页将引起缺页中断；写一个 R/W 位的 0 的页将引起保护中断。这此因访问页而引起的
中断称为“页故障”。
线性地址的长度是 32 位，可表达的地址空间是 4GB，也就是 1M 个页面。如果用一个
线性页表描述，表的长度将达到 1M 项，占据 4GB 空间（每个表项长为 4 字节），如此大
的页表检索起来显然是低效的，而且对小尺寸的进程来说也十分浪费。为解决这个问题，
x86 系统采用二级分页机制。二级分页的方法是把所有页表项按 1K 为单位划分为若干个（1
－1K 个）页表，每个页表的大小为 1KX4=4K，正好占据一个页帧。另设一个项目录表来
记录各个页表的位置，即页表的页帧号。页目录表的项数是 1K 也占一个页帧。可以看出，
二级页表占用的总空间范围从 8KB 到约 4MB，可描述 4MB－4GB 的地址空间。
采用二级分页时，线性地址由三个部分组成，分别为页目录号、页表号和页内位移，
在 32 位地址中，高 10 位和中间 10 位分别是页目录号和页表号，寻址范围都是 1K；低 12
位为页内位移，寻址范围为 4K。二级分页的地址划分及地址变换过程如图 9.12 所示。
图 9.12 二级页地址变换示意图
当进程运行时，其页目录地址加载到 CPU 的 cr3 控制寄存器中，地址变换的过程是：
先通过页目录号查找页目录表，得到页表地址，再根据页表号查找页表，得到页帧号，页
帧号与页内位移相拼得到物理地址。
页目录和页表存放在内存中，要访问内存中的某一单元需要三次访问内存。第 1 次是
查页目录表，第 2 次是查页表，第 3 次是完成对内存单元的读写操作。这样会降低指令的
执行速度。为缩短查页表的时间，X86 系统采用了快表技术，在 CPU 中设置页表高速缓存
（Translation Lookaside Buffer，TLB）也称为快表。TLB 中存放了常用的页表条目，它的
访问速度比内存页表要高得多。在地址映射时，MMU 会优先在 TLB 中查找页表项，如果
命中则立即形成物理地址，否则就从内存页表中查找，并将找到的页表项加载到 TLB 中。
9.4.2 Linux 的内存管理方案
1.Linux 的地址变换
Linux 系统采用请求页式存储管理。在大多数硬件平台上(如 RISC 处理器)，页式管理
都能很好地工作。这些平台与 x386 系列平台不同，它们采用的是分页机制，基本上不支持
分段功能。但是，x86 体系结构在发展之初因受到 PC 机内存容易的限制使用了分段的机制，
即线性地址＝段基址+段内位移。为了适应这种分段机制，Linux 利用了共享 0 基址段的方
式，使 x86 的段式映射实际上不起作用。对于 Linux 来说，虚拟地址与线性地址是一样的，
只需进行页式映射即可得到物理内存地址。这使得地址变换得 。
x86 上的 Linux 进程需要使用多个段，主要分别用于用户态与核心态的代码段、数据段
和栈段。虽然这些段的基址都设为 0，起不到段映射的作用，但却可以起到段保护的作用。
每个段除了基址外还有“存取权限”和“特权级别”设置。代码段和数据段的存取权限不
同，可以限制进程对不同内存区的访问操作。用户态的段与核心态的段的特权级不同，在
进程运行模式切换进段寄存器也切换，从而使进程获得或失去内存访问特权。
2.Linux 多级分页机制
对于 32 位系统来说，二级分页已足够了，但 64 位系统需要更多分级的分页机制。为
此，Linux2.6 后的新内核采用了四级分页的页表模型，四级页表分别是页全局目录、页上
级目录、页中间目录和页表。在这种分页机制下，一个完整的线性地址也相应地分为五部
份。图 9.13 说明了四级分页的线性划分及地址变换过程。
图 9.13 四级分页地址变换图
如，x86-64 系统采用四级页，启用了 PAE 的 x86-32 系统采用了三级页表，普通的 x86
－32 系统采用二级页表。
为适应 x86 平台的二级页表硬件结构，Linux 系统采用了一种简单的结构映射策略，就
是蒋线性地址中的页全局目录号和页表号对应于 x86 的页目录和页表，取消页上级目号和
页中间目录号字段，并把它们都看作 0。从结构上看，页上级目录和页中间目录都只含有
一个表项（０号）的目录，也就是说失去了目录索引的功能。它们的作用只是将页全局目
录的索引直接传递到页表，形成实质上的二级分页。这种做法即保持了平台的兼容性，又
兼顾了寻址特性和效率。
3.Linux 的虚存实现方式
Linux 通过页面交换来实现虚存，所有的页入和页出交换操作都是内核透明地实现的。
在建立进程时，整个进程映像并没有全部装入物理内存，而是链接到进程的地址空间中，
在运行过程，系统为进程按需动态调页。
由于页面交换程序的执行在时间上有较大的不确定性，影响系统的实时响应性能，故
在实时系统中不宜采用。为此 Linux 提代了系统调用 swapon()和 swapoff()来开启或关闭交
换机制，默认是开启的。2.6 版的内核还允许编译无虚存的系统。关闭虚存或无虚存系统的
实时性高，但要求有足够的内存来保证任务的执行。
9.4.3 进程地址空间的管理
1. 进程的地址空间
进程的地址空间是进程可以使用的全部线性地址的集哈，因此也称为线性地址空间或
虚拟地址空间。进程地址空间是进程看待内存空间的一个抽象视图，它屏蔽了物理存储器
的实际大小和分布细节，使进程得以在一个看似连续且足够大的存储空在间中存放进程映
像。
在 32 位的 x86 平台上，每个 Linux 进程拥有 4GB 的地址空间。这 4GB 的空间分为两
部分：最高 1GB 供内核使用，称为“内核空间”较低的 3GB 供用户进程使用，称为“用
户空间”。因为每个进程都可以通过系统调用执行内核代码，因此，内核空间由系统内的
所有进程共享，而用户空间则是进程的私有空间。
2. 地址空间的结构
3GB 是用户空间的上限，实际的进程映像只会占用其中的部分地址，为方便管理访问
控制，进程的映像划分为不同类型的若干个片段，每个片段占用地址空间中的一个区间。
这些被映像占用的地址区间称为虚存区（Virtual Memory Area）。根据映像不同，虚存区
分为以下几种：
（1）代码区（text）：用于容纳程序代码。
（2）数据区（data）：用于容纳已被初识化的全局变量。
（3）BSS 区（bss）：用于容纳示初识化全局变量。
（4）堆（heap）：用地动态存储分配的区
（5）栈（stack）：用于容纳局部变量、函数参数、返回地址和返回值等动态数据。
用虚存区的概念来讲,一个进程的实际地址空间是由分布在整个地址空间中的多个虚
存区组成的.每个虚存区中的映象都是同一类型的映象，拥有一致的属性和操作，因而可以
作为单独的内存对象来管理，独立地设置各自的存取权限和共享特性。如，代码区允许读
和执行；数据区可以是只读的或读定的；共享代码区允许多进程共享等。
图 9.14 所示一个小进程的地址空间。由于只是为了示意，这个程序没有采用动态库，
因此结构构成很简单，实际的进程结构要复杂些。用 pmap 命令可以查看一个进程所拥有
的所有虚存区。命令是：pmap 进程号
图 9.14 显示该进程拥有 5 个虚存区，分布在进程的用户空间中。图中未覆盖的空白区
是没有占用的空地址,是进程不可用的。虚存区是进程创建时建立的，不过进程可以在需要
时动态地添加或删除虚存区，从而改变自己的可用地址空间。
说明：虚存区只是进程的观点，并非实际内存布局。虚存区的意义在于，能够在一维
的线性地址空间中，通过划分虚存来实现代码的分段共享与保护。因此说，Linux 虽然采用
的是页式存储方案，却具备了段式存储方案的模块化管理的优势，而且管理上要简单得多。
因为段式管理中需要为一个进程分配多个地址空间。
图 9.14 Linux 进程地址空间的结构图
3. 地址空间的映射
由虚存区构成的地址空间是个虚拟空间的概念，是进程可用的地址编号的范围，并不
存在实际的存储单元。进程映象因使用这些地址而“位于”地址空间中，而不是存储在其
中。进程映象只能存放在物理存储空间中，如硬盘或物理内存。因此必须在虚存区的地址
与物理存储空间的地址之间建立起联系，这种联系就称为地址空间映射。只有建立起映射
关系，进程映象才能够真正被使用。
进程的址空间的映射方式如图 9.15 所示。对地址空间需要建立两方面上的映射，一是
虚存到文件的映射，叫为文件映射，二是虚存到实存的映射，叫为页表映射。
图 9.15 进程地址空间的映射关系
（1）文件映射
进程的静态映象以映象文件（即可执行文件）的形式驻留在硬盘存储空间。在进程创
建时需要为其构建地址空间，方法是映象文件中相应部分的内容构建虚存区。当然映象不
是被调入虚存区，而是在映象文件与虚存区之间建立地址映射，这就是文件映射。如同 C
语言用指针引用目标变量一样，进程通过虚存区来引用文件中的映象。建立文件映射后，
进程的地址空间就构建完成了。
虚存区文件映射的方式是：text 区和 data 区被映射到磁盘上的可执行文件;stack 区无需
映射;BSS和heap区为匿名映射,即不与任何实际文件对应的映射.BSS和heap区的映射对象
是一个抽象的“零页”文件，映射到零页文件的区将是全 0。
虚存区覆盖的地址空间是已建立映射的,因此是进程可以访问的、有效的地址空间。没
有建立映射的空白空间是进程不可用的，唯一的例外是栈增长。栈的空间会随着进程的执
行而动态增长。当栈超出其所有的虚存区容量时将触发一个页故障，内核处理故障时会检
查是否还有空间来增长栈。一般情况下，若栈的大小低于上限（通常是 8MB）是可以增长
的。如果确实无法增长了就会产生“栈溢出”异常，导致进程终止。、除栈之外，其他任
何对未映射地址区的访问都触发页故障，企图写一个只读区也会触发页故障。对这灰页故
障的处理是向进程发“段错误”信号 SIGSEGV，使进程终止。
（2）页表映射
文件映射只是将文件中的映象映射进了虚存空间，而进入了物理内存的映象则是通过
页表来映射的。建立了页表映射的地址空间部分是进程实际占有的、可直接访问的部分。
内核中设有一个独立的内核页表，用来映射内核空间。各个进程的页全局 768 项是进
程自己的页表，768 之后的项则共享内核页表。内核页表将内核空间映射到物理内存的低
端，进程页表将用户空间映射到 1GB 之上的物理内存空间。当进程运行在用户空间进使用
的是自己的进程页表，一量陷入内核就开始使用内核页表了。
进程开始执行时，只有很少一部分虚存区的映象装入物理内存，其余部分还在外存。
当进程方试图访问一个不在内存的地址是，CPU 将引发一个页故障中断。页故障处理程序
根据虚存区的文件映射信息在文件中找到相应位置的映象，将其从硬盘调入物理内存，为
其建立相应的页表映射，然后重新执行访问操作。
映象进入内存后也并非始终驻留内存中。页式虚存的页面交换操作可能会将其换出到
硬盘的交换空间中。内存与交换空间的映射关系由仙核确定，用户进程是看不到的。
4. 地址空间的描述
（1）虚存区的描述
Linux 内核虽然是用 C 语言写成的，但它在许多方面实际采用了面向对象的思想，将
一些资源抽象成对象来使用，如内存对象、文件对象等。
虚存区就是按照这种方式描述的一类对象。虚存区对象的描述结构是 vm_area_struct，
该结构中包含了虚存区的属性数据，如区的起始地址 vm_start 和结束地址 vm_end、访问权
限 vm_page_prot、映射的文件 vm_file、文件偏移量 vm_pgoff、链表指针 vm_next 等，此外
还有一个虚存区操作集的指针 vm_ops，它指向一组针对虚存区的操作函数的函数指针。这
些函数，这些函数包括增加虚存区 open()和删除虚存区 close()。
9.5 习题
1．存储管理的主要功能是什么。
2．什么是逻辑地址？什么是物理地址？为什么要进行地址变换。
3．静态地址变换与动态地址变换有什么区别？
4．简述页式分配思想和地址变换机制。
5．页式和段式内存管理有什么区别？
6．在页式存储系统中，若页面大小为 2 KB，系统为某进程的 0、1、2、3 页面分配的
物理块为分别 5、10、4、7，求出逻辑地址 5678 对应的物理地址。
7．在页式存储系统中，如何实现存储保护和扩充？
8.Linux 系统采用的存储管理方案是什么？





Linux操作系统复习资料

一、单选题

1.使用 tar 命令的（ ）选项可以创建一个.tar 归档文件
A.x
B.z
C.c
D.f
答案为: C

2.能够列出最近使用过的命令的命令是什么？（ ）
A.find
B.history
C.cat
D.ls
答案为: B

3.rmdir 命令的作用是什么？（ ）
A.删除一个有文件的目录
B.创建一个目录
C.改变当前的目录
D.删除一个空的目录
答案为: D

4. 哪一条命令可以用来查看文件内容？（ ）
A.pwd
B.man
C.cat
D.ls
答案为: C

5.快速启动网卡“eth0”的命令是（ ）
A.ifup eth0
B.ifnoshut eth0
C.ipconfig eth0 noshut
D.ifconfig eth0 noshut
答案为: A

6.[ptname@localhost ~]$ alias cls=‘clear’ [ptname@localhost ~]$ alias [ptname@localhost ~]$ cls 所表示的是（ ）
A.创建一个alias，可以使用cls 的字符，执行系统能clear 命令
B.创建一个alias，可以使用alias的字符，清除屏幕功能
C.创建一个alias，可以使用cls 的字符，执行系统能alias命令
D.以上都不对
答案为: A

7.[ptname@localhost ~]$ tar cvf /tmp/backetc.tar /etc是（ ）
A.隐藏/etc 目录下的文件到/tmp目录下名为backetc
B.修改/etc 目录下的文件到/tmp目录下名为backetc
C.保存/etc 目录下的文件到/tmp目录下名为backetc
D.删除/etc 目录下的文件到/tmp目录下名为backetc
答案为: C

8.[ptname@localhost ~]$ find . -size +1000c –print是（ ）
A.查找当前目录大于10K的文件
B.查找当前目录大于100K的文件
C.查找当前目录大于1000K的文件
D.查找当前目录大于1K的文件
答案为: D

9.操作系统接口的功能就是提供一个用户使用系统的界面，根据服务对象的不同，操作系统的接口可以划分为两类，一是供用户使用的用户级接口中，二是（ ）
A.设计接口
B.程序级接口
C.交互级接口
D.图形级接口
答案为: B

10.Linux 的运行级别共有（ ）
A.1 级
B.7级
C.5 级
D.3 级
答案为: C

11.在下列目录中，存放系统内核和管理程序相关的文件的是（ ）
A.boot
B.root
C.home
D.etc
答案为: A

12.下列系统文件中用来记录用户信息的是 （ ）
A./etc/h
B./etc/shadow
C./etc/group
D./etc/passwd
答案为: D

13.Shell 位于系统中的什么位置？（ ）
A.硬件与内核之间
B.内核之内
C.内核与命令行之间
D.命令行之外
答案为: C

14.单用户模式的运行级是什么？（ ）
A.运行级 4
B.运行级 3
C.运行级 2
D.运行级 1
答案为: D

15. Red Hat Linux 默认使用何种文件系统类型？（）
A.swap
B.ext3
C.fat
D.ios9600
答案为: B

16. 如果要修改默认的 www 服务的端口号为 8080，则需要修改配置文件中的（ ） 一行
A.listen 8080
B.keepalive 80
C.timeout 8080
D.pidfile 80
答案为: A

17.在默认的安装中，Apache 把自己的配置文件放在了（ ）目录中
A./etc/apache/
B./etc/
C./etc/httpd/conf/
D./etc/httpd/
答案为: C

18.在一个新分区上建立文件系统应该使用命令（ ）
A.fdisk
B.makefs
C.mkfs
D.format
答案为: C

19. 使用 gzip 对压缩文件进行解压缩的命令选项是（)
A.-d
B.-t
C.-v
D.-l
答案为: A

20.[rube@yujun rube]$pwd 该命令所显示的信息是（ ）
A./home/rube
B./rube
C.rube
D.rube/
答案为: A

21.在 Linux 中，有关 IDE 设备命名编号，正确的有（ ）
A.hda 第一个 IDE 控制器，主设备
B.hdb 第二个 IDE 控制器，主设备
C.sdb 第二个 IDE 控制器，次设备
D.sda 第一个 IDE 控制器，主设备
答案为: A

22.为了保证系统的安全，现在的 LINUU 系统一般将/etc/passwd 密码文件加密 后，保存在（ ）文件
A./etc/group
B./etc/netgroup
C./etc/libasafe.notify
D./etc/shadow
答案为: D

23.在 Linux 环境下，能实现域名解析的功能软件模块是：（ ）
A.apache
B.dhcpd
C.BIND
D.SQUID
答案为: C

11.[root@localhost ~]# shutdown 10 “shutdown“表述正确的是（ ）
A.所有登录用户的屏幕上都会出现root发出的关机“shutdown“提示信息
B.10分钟后，所有登录用户的屏幕上都会出现root发出的关机“shutdown“提示信息
C.直接关机
D.10分钟后，关机后再开机
答案为: B

24.通过按：alt+ctrl+F1或者alt+F1是提（ ）
A.转换到虚拟终端 1（tty1）
B.转换到虚拟终端 2（tty2）
C.转换到虚拟终端 3（tty3）
D.转换到虚拟终端 4（tty4）
答案为: A

25.进程控制的目标是（ ）
A.使多个进程能够平稳高效地并发执行
B.不能共享系统资源
C.不能通信
D.不能传递信息
答案为: A

26关于Shell语言错误的是（ ）
A.Shell语言是一种解释性语言
B.Shell语言是基于字符串的语言
C.Shell语言是命令级语言
D.Shell语言是要编译后才能执行的语言
答案为: D

27.Linux系统的命令行接口是由Shell提供的方本方式的界面，也称为（ ）界面
A.程序
B.Ｘ
C.Shell
D.Bell
答案为: C

28.每个进程都独立地执行，各自按照不可预知的速度向前推进。进程之间的协调运行由操作系统负责为（ ）
A.动态性
B.异步性
C.并发性
D.独立性
答案为: B

29.以长格式列目录时，若文件 test 的权限描述为： drwxrw-r-- ，则文件 test的类型及文件主的权限是（）
A.目录文件、读写执行
B.目录文件、读写
C.普通文件、读写
D.普通文件、读
答案为: B

30.以下命令中，可以将用户身份临时改变为 root 的是（）
A.SU
B.su
C.login
D.logout
答案为: B

31.在 UNIX/Linux 系统添加新用户的命令是（）
A.groupadd
B.usermod
C.userdel
D.useradd
答案为: D

32.当使用 mount进行设备或者文件系统挂载的时候， 需要用到的设备名称位于（）目录
A./home
B./bin
C./etc
D./dev
答案为: D

33.在字符控制台界面，用exit命令或（ ）键即可退出系统。
A.ctrl+a
B.ctrl+b
C.ctrl+c
D.以上都不对
答案为: D

34.Shell启动完成后，显示命令提示符，提示用户可以输入命令了，对于普通用户，系统的默认提示符是$，对物root用户，系统的默认提示符是（ ）
A.*
B.#
C.$
D.%B
答案为: 

35.显示目录下的内容是（ ）
A.pwd/cd
B.ls
C.id
D.以上都不对
答案为: B

36.命令〉〉文件，命令〉文件的说法正确的是（ ）
A.两个都是标准重定向功能效果一样
B.他们的区别在于第二个操作是附加输出重定向是会保留文件内原有的内容
C.他们的区别在于第二个操标准重定向是会保留文件内原有的内容
D.他们的区别在于第一个操作是附加输出重定向是会保留文件内原有的内容
答案为: B

37.关于执行[root@localhost ~]# cat afile和[root@localhost ~]# cat
A.两个cat命令的功能是等效的，但执行方式却不同
B.第1个cat带有一个文件参数afile，直接读取afile文件
C.第2个cat没带任何参数，运行时在读stdin文件，然后重定向到afile文件
D.两个cat命令的功能不等效，但执行方式相同
答案为: B

38.Linux系统转化为至多12个虑拟控制台，系统启动时默认在前面几个控制台上启动1个图形控制台和（ ）个字符控制台。
A.6
B.12
C.24
D.48
答案为: A

39.创建一个名为words的文件是（ ）
A.[ptname@localhost ~]$ cj words
B.[ptname@localhost ~]$ v words
C.[ptname@localhost ~]$ mm words
D.[ptname@localhost ~]$ vim words
答案为: D

40.[ptname@localhost ~]$ df所表示的是（ ）
A.获取文件系统总的总空间
B.获取文件系统总的已使用空间
C.获取文件系统总的不能使用的空间
D.获取文件系统总的剩余空间
答案为: A

41.使用ls命令检查 home 目录下所有文件信息（ ）
A.[ptname@localhost ~]$ ls
B.[ptname@localhost ~]$ ls –a
C.[ptname@localhost ~]$ ls –ff
D.以上都不对
答案为: B

42.显示用户的主目录的命令是什么（ ）
A.echo $HOME
B.echo $VAR
C.echo $USERDIR
D.echo $ENV
答案为: A

43.以长格式列目录时，若文件 test 的权限描述为： drwxrw-r-- ，则文件 test的类型及文件主的权限是（）
A.目录文件、读写执行
B.目录文件、读写
C.普通文件、读写
D.普通文件、读
答案为: A

44.以下命令中，可以将用户身份临时改变为 root 的是（）
A.SU
B.su
C.login
D.logout
答案为: B

45.若要将当前目录中的 myfile.txt 文件压缩成 myfile.txt.tar.gz，则实现的命令为（）
A.tar –cvf myfile.txt myfile.txt.tar.gz
B.tar –zcvf myfile.txt myfile.txt.tar.gz
C.tar –zcvf myfile.txt.tar.gz myfile.txt
D..tar –cvf myfile.txt.tar.gz myfile.txt
答案为: C

46.在 UNIX/Linux 系统添加新用户的命令是（）
A.groupadd
B.usermod
C.userdel
D.useradd
答案为: D

47.当使用 mount进行设备或者文件系统挂载的时候， 需要用到的设备名称位于（）目录
A./home
B./bin
C./etc
D./dev
答案为: D

48.下面哪个命令可以压缩部分文件（）
A.tar -dzvf filename.tgz *
B.tar -tzvf filename.tgz *
C.tar -czvf filename.tgz *
D.tar -xzvf filename.tgz *
答案为: C

49.CentOS LINUX 默认使用的文件系统类型为（）
A.ext2
B.ext3
C.FAT
D.swap
答案为: B

50.在 Shell 脚本中，用来读取键盘输入的内容并将其赋值给 Shell 变量的命令是（）
A.fold
B.join
C.tr
D.read
答案为: D

51.把home 目录下所有以“_a1”结尾的文件移动到“ml”目录中的是（ ）
A.[ptname@localhost a_zhous]$ mv ~/*_a1 a_zhous/
B.[ptname@localhost a_zhous]$ ls ~/*_a1 a_zhous/
C.[ptname@localhost a_zhous]$ dw ~/*_a1 a_zhous/
D.[ptname@localhost ml]$ mv ~/*_a1 ml/
答案为: D

52.Shell启动完成后，显示命令提示符，提示用户可以输入命令了，对于普通用户，系统的默认提示符是$，对物root用户，系统的默认提示符是（ ）
A.*
B.#
C.$
D.%
答案为: B

53.命令〉〉文件，命令〉文件的说法正确的是（ ）
A.两个都是标准重定向功能效果一样
B.他们的区别在于第二个操作是附加输出重定向是会保留文件内原有的内容
C.他们的区别在于第二个操标准重定向是会保留文件内原有的内容
D.他们的区别在于第一个操作是附加输出重定向是会保留文件内原有的内容
答案为: B

54.显示目录下的内容是（ ）
A.pwd/cd
B.ls
C.id
D.以上都不对
答案为: B

55.关于执行[root@localhost ~]# cat afile和[root@localhost ~]# cat
A.两个cat命令的功能是等效的，但执行方式却不同
B.第1个cat带有一个文件参数afile，直接读取afile文件
C.第2个cat没带任何参数，运行时在读stdin文件，然后重定向到afile文件
D.两个cat命令的功能不等效，但执行方式相同
答案为: B

56.在poem文件中搜索and，并显示匹配的行（ ）
A.[root@localhost ~]# grep poem ａnd
B.[root@localhost ~]# grep -c ａnd poem
C.[root@localhost ~]# grep -v ａnd poem
D.[root@localhost ~]# grep ａnd poem
答案为: D

57.[root@localhost ~]# who -q表示的是（ ）
A.显示各列的标题
B.显示用户数
C.以上都对
D.显示登录的用户名和用户数
答案为: B

58.在字符控制台界面，用exit命令或（ ）键即可退出系统。
A.ctrl+a
B.ctrl+b
C.ctrl+c
D.以上都不对
答案为: D

59.Linux系统转化为至多12个虑拟控制台，系统启动时默认在前面几个控制台上启动1个图形控制台和（ ）个字符控制台。
A.6
B.12
C.24
D.48
答案为: A

60.快速的查看某个文件的最后几行是（ ）
A.[ptname@localhost ~]$ head words
B.[ptname@localhost ~]$ form words
C.[ptname@localhost ~]$ end words
D.以上都不对
答案为: D

61.创建一个名为words的文件是（ ）
A.[ptname@localhost ~]$ cj words
B.[ptname@localhost ~]$ v words
C.[ptname@localhost ~]$ mm words
D.[ptname@localhost ~]$ vim words
答案为: D

62.[ptname@localhost ~]$ df所表示的是（ ）
A.获取文件系统总的总空间
B.获取文件系统总的已使用空间
C.获取文件系统总的不能使用的空间
D.获取文件系统总的剩余空间
答案为: A

63.可以使用（ ）查看记录进程ＰＣＢ中相关的信息
A.ps
B.pf
C.pd
D.pt
答案为: A

64.进程已经分配到了除ＣＰＵ之外的所有资源，这时的时程状态称为（ ）
A.运行态
B.等待态
C.就绪态
D.控制态
答案为: C

65.删除文件a.out的是（ ）
A.[root@localhost ~]# mv a.out
B.[root@localhost ~]# ls a.out
C.[root@localhost ~]# wc a.out
D.[root@localhost ~]# rm a.out
答案为: D

66.[root@localhost ~]# mkdir temp，[root@localhost ~]# cp *.o temp表示的是（ ）
A.将*.0的文件全部从mkdir中删除
B.将*.0的文件全部从temp中删除
C.将*.0的文件全部复制到mkdir
D.以上都不对
答案为: D

67.创建、删除目录的是（ ）
A.pwd/cd
B.ls
C.id
D.以上都不对
答案为: D

二、多选题

1.以下哪些是Linux操作系统的特点？
A.开放性
B.灵活性
C.低廉性
D.广泛性
答案为: ABCD

2.Linux的调度策略有（）
A.优先级策略和时间片策略
B.根据进程对IO和处理器的请求多少对进程进行分类
C.随机性策略
D.倒序策略
答案为: 
    优先级策略和时间片策略
    根据进程对IO和处理器的请求多少对进程进行分类

3.echo 命令可以用来显示?
A.参数
B.文本字符
C.过滤内容
D.shell 变量
答案为: 
    参数
    文本字符
    shell 变量

4.Linux 的登录模式有（ ）
A.图形模式
B.Windows 模式
C.DOS 模式
D.文本模式
答案为: 
    图形模式
    文本模式

5.Shell程序的功能就是执行Shell命令，执行命令的主要方式是创建一个子进程（ ）
A.让这个子进程来执行命令的映像文件
B.Shell进程是所有在其下执行的命令的父进程
C.让这个子进程来执行root的映像文件
D.Shell进程是所有在其下执行的命令的子进程
答案为: 
    让这个子进程来执行命令的映像文件
    Shell进程是所有在其下执行的命令的父进程

6.Linux的进程共有（ ）种基本状态
A.运行
B.就绪
C.睡眠
D.暂停和僵死
答案为:ABCD 

7.关于 linux 下列说明哪些是正确的?
A.Linux 是一个开放源码的操作系统
B.Linux 是一个类 UNIX 的操作系统
C.Linux 是一个多用户的操作系统
D.Linux 是一个多任务的操作系统
答案为: ABCD

8.进程的控制块中包含（）
A.操作时间
B.进程id和父进程id
C.所需资源
D.运行时间
答案为: 
    进程id和父进程id
    所需资源

9.进程通信的方式有（）
A.管道
B.消息队列
C.套接字
D.共享存储
答案为: ABCD

10.以下哪些操作系统属于类Unix操作系统？
A.Linux
B.BSD和MacOS
C.Windows
D.dos
答案为: 
    Linux
    BSD和MacOS

11.在命令模式移动光标可以使用哪些键？
A.k
B.l
C.a
D.上箭头
答案为: D

12.以下哪些是Linux操作系统的特点？
A.开放性
B.灵活性
C.低廉性
D.广泛性
答案为: ABCD

13.Linux虚拟文件系统支持的文件系统包括（）
A.通用文件系统
B.物理文件文件系统
C.网络文件系统和特殊文件系统
D.信息文件系统
答案为: C

14.echo 命令可以用来显示?
A.参数
B.文本字符
C.过滤内容
D.shell 变量
答案为: 
    参数
    文本字符
    shell 变量

15.程有3个基本的状态（ ）
A.中断态
B.就绪态
C.运行态
D.等待态
答案为: 
    就绪态
    运行态
    等待态

16.设备分配的方法有（）
A.共享分配和独享分配
B.批次分配
C.虚拟分配
D.单次分配
答案为: A

17.Linux中I/O的系统结构可以分为（）
A.虚拟文件系统
B.驱动层和物理设备
C.虚拟层
D.底层
答案为: 
    虚拟文件系统
    驱动层和物理设备

18.操作系统将设备分为（）这几类
A.块设备和字符设备
B.支持设备
C.网络设备
D.移动设备
答案为: 
    块设备和字符设备
    网络设备

19.虚拟文件系统设置的对象包括（）
A.超级块对象
B.索引节点对象
C.文件对象
D.目录项对象
答案为: ABCD

20.Linux虚拟文件系统支持的文件系统包括（）
A.通用文件系统
B.物理文件文件系统
C.网络文件系统和特殊文件系统
D.信息文件系统
答案为: C

三、判断题

1. find . -name core -exec rm {} \ ; 能用来删除当前目录及其子目录下名为‘core'的文件
答案为: O

2.当运行在多用户模式下时，用 CONFROL+ALT+F*可以切换6虚拟用户终端
答案为: X

3.除非特别指定，cp 假定要拷贝的文件在当前目录
答案为: O

4. 在 vi 编辑器里，:200命令能将光标移到第200 行
答案为: X

5. 按 Ctrl-D键能中止当前运行的命令
答案为: X

6.&符号加在命令后面可以在后台执行程序
答案为: O

7.在 Linux 系统，默认的 shell 是 ash
答案为: X

8.用”useradd jerry”命令添加一个用户，这个用户的主目录是 /home/jerry
答案为: O

9. runx命令用来启动 X window
答案为: X

10.命令”tail myfile ”表示它显示 myfile 的最后 10 行
答案为: X

11. 在vi 模式下，d命令用来删除光标处的字符
答案为: X

12. 用 vi 打开一个文件, :1,$s/old/new/g用字母”new”来代替字母”old”
答案为: O

13. 如果需要新建一个用户 blue，其所属用户组的gid 为 505，可使用# useradd bule -p 505
答案为: X

14.在 Linux 中，当 root 密码丢失后，应该进入单用户模式后修改 root 密码
答案为: o

15.以下 Linux 命令中ipconfig用来显示和设置网络接口的配置信息
答案为: X

16.截取查看文件头部（头 10 行）用命令cat
答案为: X

17.export命令是用来定义 shell 的全局变量
答案为: O

18.tr命令可以将大写字母转换成小写字母
答案为: O





形成性考核

试题 1
以下哪个不属于操作系统？
选择一项：
a. Linux
b. Windows
c. MacOS
d. Oracle
正确答案是：Oracle

试题 2
以下描述正确的是？
选择一项：
a. Linux就是批处理系统
b. 批处理系统可以同时执行多个任务
c. Windows是批处理操作系统
d. 批处理系统出现早于分时系统
正确答案是：批处理系统出现早于分时系统

试题 3
以下哪个是移动操作系统？
选择一项：
a. Windows2003
b. Android
c. Linux
d. WindowsXP
正确答案是：Android

试题 4
Linux最早发布于哪一年？
选择一项：
a. 1992
b. 1991
c. 1990
d. 1993
正确答案是：1991

试题 5
第一个企业版的Linux是哪一个？
选择一项：
a. CentOS
b. Ubuntu
c. Debian
d. RedHat
正确答案是：RedHat

试题 6
以下哪个不是内核的组成部分？
选择一项：
a. 系统调用接口
b. 驱动程序
c. 进程管理
d. C语言编译器
正确答案是：C语言编译器

试题 7
Linux下常用文本编辑工具是？
选择一项：
a. Notepad
b. DreamWeaver
c. EditPlus
d. VIM
正确答案是：VIM

试题 8
Linux的终端软件英文名称是什么？
选择一项：
a. console
b. cmd
c. terminal
d. background
正确答案是：terminal

试题 9
下载安装软件的命令是什么？
选择一项：
a. sudo
b. setup
c. apt-getinstall
d.  vim-version
正确答案是：apt-getinstall

试题 10
以下哪些是Linux操作系统的特点？
选择一项或多项：
a. 开放性
b. 低廉性
c. 广泛性
d. 灵活性
正确答案是：开放性, 灵活性, 低廉性, 广泛性

试题 1
修改密码的命令是？
选择一项：
a. update
b.  passwd
c. password
d. change
正确答案是： passwd

试题 2
进入某一文件夹的命令是？
选择一项：
a.  help
b.  ll
c. cd
d.  ls
正确答案是：cd

试题 3
列表显示所有文件的命令是？
选择一项：
a. cd
b.  pwd
c. echo
d. ls
正确答案是：ls

试题 4
打印信息的命令是？
选择一项：
a. ls
b. pwd
c. echo
d. ll
正确答案是：echo

试题 5
列表显示文件详细信息的命令是？
选择一项：
a. ll
b. cd
c. help
d. ls
正确答案是：ll

试题 6
 查看”当前工作目录“的完整路径？
选择一项：
a. echo
b. cd
c. \h
d.  pwd
正确答案是： pwd

试题 7
查看系统当前运行所有程序的命令是？
选择一项：
a. top
b. list
c.  ls
d. show
正确答案是：top

试题 8
系统配置文件一般放在哪个目录下？
选择一项：
a. etc
b. tmp
c.  usr
d. dev
正确答案是：etc

试题 9
增加用户的命令是？
选择一项：
a.  deluser
b. appenduser
c. insertuser
d. adduser
正确答案是：adduser

试题 10
以下哪些描述是手机root后会产生的？
选择一项或多项：
a. 可以任意安装软件
b. 获取最高用户权限和增加系统风险
c. 可以提高打印速度
d. 可以提升网络连接速度
正确答案是：获取最高用户权限和增加系统风险, 可以任意安装软件

试题 1
vi应该在哪个模式下来输入文件内容？
选择一项：
a. 编辑工作模式
b. 操作工作模式
c. 命令工作模式
d. 输入工作模式
正确答案是：编辑工作模式

试题 2
从命令模式切换到编辑模式应该使用哪个命令？
选择一项：
a. a
b. o
c.  i
d. u
正确答案是： i

试题 3
删除当前行应该使用哪个命令？
选择一项：
a. del
b. dl
c. dd
d. dt
正确答案是：dd

试题 4
撤消上一行操作应该使用哪个命令？
选择一项：
a. u
b. a
c. o
d.  i
正确答案是：u

试题 5
复制当前行使用哪个命令？
选择一项：
a. yy
b. cp
c. ps
d. p
正确答案是：yy

试题 6
粘贴应该使用哪个命令？
选择一项：
a. ps
b. p
c. yy
d. cp
正确答案是：p

试题 7
使用哪个命令可以显示vi中的行号？
选择一项：
a.  :number
b.  :setnumber
c.  :shownumber
d.  :show
正确答案是： :setnumber

试题 8
在查找替换命令中，使用哪个符号来分隔要查找和替换的关键字？
选择一项：
a.  ,
b. /
c.  |
d.  \
正确答案是：/

试题 9
保存并退出vi的命令是哪个？
选择一项：
a.  :w
b.  :wq
c.  :q!
d.  :q
正确答案是： :wq

试题 10
在命令模式移动光标可以使用哪些键？
选择一项或多项：
a. a
b. k
c. 上箭头
d. l
正确答案是：k, l

试题 1
C语言头文件一般以什么名称结尾？
选择一项：
a. a
b. c
c. h
d. f
正确答案是：h

试题 2
C语言库文件一般以什么名称结尾？
选择一项：
a. h
b.  so
c. c
d. a
正确答案是： so

试题 3
gcc在编译时，使用哪个参数来设置输出的文件名？
选择一项：
a. o
b. c
c.  e
d.  i
正确答案是：o

试题 4
man命令查找Linux系统命令的用法应该使用哪个子命令？
选择一项：
a. ２
b. ３
c. ４
d. １
正确答案是：１

试题 5
man命令查找C语言函数用法应该使用哪个子命令？
选择一项：
a. １
b. ４
c. ２
d. ３
正确答案是：３

试题 6
使用gcc经过预编译后的文件一般以什么名称结尾？
选择一项：
a. a
b. o
c.  i
d.  u
正确答案是： i

试题 7
使用gcc编译后的目标文件一般以什么名称结尾？
选择一项：
a.  i
b. a
c.  o
d. u
正确答案是： o

试题 8
以下哪些操作系统属于类Unix操作系统？
选择一项或多项：
a.  Linux
b. Windows
c. dos
d. BSD和MacOS
正确答案是： Linux, BSD和MacOS

试题 9
在Linux系统中，（　　　　）是指用户用来系统交互的设备、包括显示器、键盘和鼠标。
选择一项：
A. PC
B. 主机
C. 终端
D. 程序
正确答案是：终端

试题 10
[root@localhost ~]# useradd ptname和[root@localhost ~]# passwd ptname所表示的是（　　　　）
选择一项：
A. 添加一个ptname用户，密码是passwd
B. 添加一个ptname用户，同时确定用户为ptname
C. 添加一个ptname用户，密码是ptname
D. 添加一个ptname用户，无密码
正确答案是：添加一个ptname用户，密码是ptname

试题 1
程序的顺序执行具有顺序性、封闭性和（　　　　）
选择一项：
A. 多分支性
B. 系统性
C. 程序性
D. 可再现性
正确答案是：可再现性

试题 2
程序的并发执行具有间断生、不可再现性和（　　　　）
选择一项：
A. 重复性
B. 可测试性
C. 循环性
D. 没有封闭性
正确答案是：没有封闭性

试题 3
以下关于进程说法错误的是（　　　　）
选择一项：
A. 一个进程可以顺序执行多个程序
B. 一个程序不可以对应多个进程
C. 进程是一个可并发执行的程序在一个数据集上的一次运行
D. 进行就是程序的一次运行过程
正确答案是：一个程序不可以对应多个进程

试题 4
进程已经分配到了除ＣＰＵ之外的所有资源，这时的时程状态称为（　　　）
选择一项：
A. 控制态
B. 就绪态
C. 运行态
D. 等待态
正确答案是：就绪态

试题 5
可以使用（　　　　）查看记录进程ＰＣＢ中相关的信息
选择一项：
A. pt
B. ps
C. pf
D. pd
正确答案是：ps

试题 6
对单个进程中多条执行线索的支持，这些执行线索称为（　　　）
选择一项：
A. 线程
B. 程序
C. 进程
D. 软件
正确答案是：线程

试题 7
Linux中用于释放内存页，从而增加空闲页的数量，是由（）程序实现的。
选择一项：
a. delete
b. kswaped
c. swaped
d. key
正确答案是：kswaped

试题 8
虚拟存储技术是有机的将内存和外存结合起来，充当（）
选择一项：
a. 虚拟内存
b. 外存
c. 主存
d. 内存
正确答案是：虚拟内存

试题 9
Linux中实际使用的存储管理技术是（）
选择一项：
a. 分区虚拟存储管理
b. 页式虚拟存储管理
c. 段页式虚拟存储管理
d. 段式虚拟存储管理
正确答案是：页式虚拟存储管理

试题 10
存储管理方案有（）
选择一项或多项：
a. 段页式存储管理
b. 分区存储管理
c. 段式存储管理
d. 页式存储管理
正确答案是：分区存储管理, 页式存储管理, 段式存储管理, 段页式存储管理

试题 1
Linux中用于释放内存页，从而增加空闲页的数量，是由（）程序实现的。
选择一项：
a. kswaped
b. delete
c. key
d. swaped
正确答案是：kswaped

试题 2
虚拟存储技术是有机的将内存和外存结合起来，充当（）
选择一项：
a. 虚拟内存
b. 内存
c. 主存
d. 外存
正确答案是：虚拟内存

试题 3
Linux中实际使用的存储管理技术是（）
选择一项：
a. 页式虚拟存储管理
b. 段式虚拟存储管理
c. 段页式虚拟存储管理
d. 分区虚拟存储管理
正确答案是：页式虚拟存储管理

试题 4
存储管理方案有（）
选择一项或多项：
a. 段页式存储管理
b. 分区存储管理
c. 段式存储管理
d. 页式存储管理
正确答案是：分区存储管理, 页式存储管理, 段式存储管理, 段页式存储管理

试题 5
在分区存储管理中，内存划分方式有（）
选择一项或多项：
a. 分段式分区
b. 固定分区
c. 动态分区
d. 随机分区
正确答案是：固定分区, 动态分区

试题 6
页式存储管理的特点有（）
选择一项或多项：
a. 存储利用率最低
b. 对逻辑上统一的一类信息不方便查找和共享
c. 页的大小因系统而异和可以非连续存放
d. 内存利用率最低
正确答案是：页的大小因系统而异和可以非连续存放, 对逻辑上统一的一类信息不方便查找和共享

试题 7
交换分区中包含专用的文件系统
选择一项：
对
错
正确答案是“错”。

试题 8
在虚拟存储管理的实现过程中，因为外存也被看做虚拟内存的一部分，所以存放在外存中的程序也可以被执行
选择一项：
对
错
正确答案是“错”。

试题 9
虚拟存储技术最大的优势就是扩展了计算机系统可使用的内存空间。
选择一项：
对
错
正确答案是“对”。

试题 10
虚拟存储中因为内存空间的扩展，所以将整个程序全放置到内存中，从而加快了运行速度。
选择一项：
对
错
正确答案是“错”。



综合练习题
（一）单项选择（每题只有一个正确答案）
1、( )是计算机系统中最基本的软件，可直接管理和控制计算机的资源，合理地调度资源，使之得到充分的利用，并为用户使用这些资源提供一个方便的操作环境和良好的用户界面。
A、 操作系统
B、 数据库
C、 PS
D、 办公软件
答案为: A

2、操作系统的功能有处理器管理、存储器管理、设备管理、文件管理和（    ）
A、 资源管理
B、 语言管理
C、 程序管理
D、 用户管理
答案为: D

3、（    ）是指在内存中存在多个作业，同时处于运行状态，共享系统资源。
A、 多道批处理操作系统
B、 分时操作系统
C、 实时操作系统
答案为: B

4、Linux操作系统具有很高的安全性与稳定性、具体强大的TCP/IP支持、具有良好的可移埴性和（    ）
A、 容易使用
B、 界面良好	
C、 编程复杂
D、 源代码公开
答案为: D

5、Linux的基本系统由３个主要部份组成（    ）
A、 内核、程序和shell
B、 内核、软件和shell
C、 内核、shell和文件系统
D、 内核、文件系统和程序
答案为: C

6、在Linux系统中，（    ）是指用户用来系统交互的设备、包括显示器、键盘和鼠标。
A、 主机	
B、 终端
C、 PC
D、 程序
答案为: B

7、[root@localhost ~]# useradd ptname和[root@localhost ~]# passwd ptname所表示的是（    ） 
A、 添加一个ptname用户，密码是ptname
B、 添加一个ptname用户，同时确定用户为ptname
C、 添加一个ptname用户，密码是passwd
D、 添加一个ptname用户，无密码
答案为: A

8、进入home目录，使用＂打印工作目录＂查看的是（    ）
A、 [ptname@localhost ~]$ ls
B、 [ptname@localhost ~]$ pwd
C、 [ptname@localhost ~]$ passwd
D、 [ptname@localhost ~]$ ls -l
答案为: B

9、使用ls命令检查 home 目录下所有文件信息（    ）
A、 [ptname@localhost ~]$ ls
B、 [ptname@localhost ~]$ ls –a
C、 [ptname@localhost ~]$ ls –al
D、 [ptname@localhost ~]$ ls –ff
答案为: C

10、[ptname@localhost ~]$ mkdir a_zhous表示（    ）
A、 在home 目录创建一个a_zhous目录
B、 在home 目录创建一个a_zhous文件
C、 在home 目录创建一个a_zhous目录和文件
D、 在home 目录创建一个mkdir目录
答案为: A

11、把home 目录下所有以“_a1”结尾的文件移动到“a_zhous”目录中的是（    ）
A、 [ptname@localhost a_zhous]$ mv ~/*_a1 a_zhous/
B、 [ptname@localhost a_zhous]$ ls ~/*_a1 a_zhous/
C、 [ptname@localhost a_zhous]$ dw ~/*_a1 a_zhous/
D、 [ptname@localhost a_zhous]$ dd ~/*_a1 a_zhous/
答案为: A

12、[ptname@localhost ~]$ df所表示的是（    ）
A、 获取文件系统总的总空间
B、 获取文件系统总的剩余空间
C、 获取文件系统总的已使用空间
D、 获取文件系统总的不能使用的空间
答案为: A

13、创建一个名为words的文件是（    ）
A、 [ptname@localhost ~]$ cj words
B、 [ptname@localhost ~]$ v words
C、 [ptname@localhost ~]$ mm words
D、 [ptname@localhost ~]$ vim words
答案为: D

14、快速的查看某个文件的最后几行是（    ）
A、 [ptname@localhost ~]$ head words
B、 [ptname@localhost ~]$ form words
C、 [ptname@localhost ~]$ end words
D、 [ptname@localhost ~]$ tail words
答案为: D

15、Linux系统转化为至多12个虑拟控制台，系统启动时默认在前面几个控制台上启动1个图形控制台和（    ）个字符控制台。
A、 6
B、 7
C、 8
D、 9
答案为: A

16、在字符控制台界面，用exit命令或（    ）键即可退出系统。
A、 ctrl+a
B、 ctrl+b
C、 ctrl+c
D、 ctrl+d
答案为: D

17、Shell启动完成后，显示命令提示符，提示用户可以输入命令了，对于普通用户，系统的默认提示符是$，对物root用户，系统的默认提示符是（    ）
A、 c:\
B、 $
C、 #
D、 %
答案为: C

18、[root@localhost ~]# who -q表示的是（　　）
A、 显示登录的用户名和用户数
B、 显示各列的标题
C、 显示用户数
D、 以上都对
答案为: A

19、文件abc*是的是（　　）
A、 以abc开始的字符串
B、 以abc结尾的字符串
C、 以abc开始，后面是一个字符的字符串
D、 以abc开始，前在面是一个字符的字符串
答案为: C

20、echo ch[146-9]显示的是（　　）
A、 显示的是文件ch146-ch155
B、 显示的是文件ch1、ch4、ch6、ch7、ch8、ch9文件
C、 显示的是文件ch14和ch9文件
D、 以上都不对
答案为: D

21、Linux系统支持的目录文件是（　　）
A、 －
B、 d
C、 l
D、 p
答案为: B

22、某文件类型和权限字符串是drwxr-x---表示的是（　　）
A、 表明是一个目录文件，所有用户有读、写和执行的权限
B、 表明是一个目录文件，其它用户有读、写和执行的权限
C、 表明是一个目录文件，用户组有读、写和执行的权限
D、 表明是一个目录文件，属主有读、写和执行的权限
答案为: D

23、文件创建时默认权限可执行文件是777，非可执行文件的默认权限是（　　）
A、 777
B、 644
C、 664
D、 755
答案为: B

24、创建、删除目录的是（　　）
A、 pwd/cd
B、 ls
C、 mkdir/rmdir
D、 id
答案为: C

25、[root@localhost ~]# mkdir temp，[root@localhost ~]# cp *.o temp表示的是（　　）
A、 将*.0的文件全部从mkdir中删除
B、 将*.0的文件全部从temp中删除
C、 将*.0的文件全部复制到mkdir
D、 将*.0的文件全部复制到temp
答案为: D

26、删除文件a.out的是（　　）
A、 [root@localhost ~]# rm a.out
B、 [root@localhost ~]# mv a.out
C、 [root@localhost ~]# ls a.out
D、 [root@localhost ~]# wc a.out
答案为: A

27、在poem文件中搜索and，并显示匹配的行（　　）
A、 [root@localhost ~]# grep and poem
B、 [root@localhost ~]# grep poem and
C、 [root@localhost ~]# grep -c and poem
D、 [root@localhost ~]# grep -v and poem
答案为: A

28、关于执行[root@localhost ~]# cat afile和[root@localhost ~]# cat < afile说法错误的是（　　）
A、 两个cat命令的功能是等效的，但执行方式却不同
B、 第1个cat带有一个文件参数afile，直接读取afile文件
C、 第2个cat没带任何参数，运行时在读stdin文件，然后重定向到afile文件
D、 两个cat命令的功能不等效，但执行方式相同
答案为: D

29、命令〉〉文件，命令〉文件的说法正确的是（　　）
A、 两个都是标准重定向功能效果一样
B、 他们的区别在于第一个操作是附加输出重定向是会保留文件内原有的内容
C、 他们的区别在于第二个操作是附加输出重定向是会保留文件内原有的内容
D、 他们的区别在于第二个操标准重定向是会保留文件内原有的内容
答案为: B

30、vi的启动过程是先建立一个编辑缓冲区，若指定文件存在，则将其内容读到编辑缓冲区中，若指定文件不存在，则（　　）
A、 建立此文件	
B、 强行退出
C、 出错
D、 关机
答案为: A

31、进入输入模式的方法是按insert键，编辑完成后可用（　　）将修改后的内容保存到文件中并退出vi
A、 :q
B、 :q!
C、 :wq
D、 :exit
答案为: C

32、删除文本，每按一下x键或delete键就会删除一个字符，若要删除的文本较多时，可以使用（　　）删除光标所在的行。
A、 dd
B、 dw
C、 d$
D、 J
答案为: A

33、撤销上一个命令所做的修改，恢复到命令执行前的样子其中，撤销上一个命令所做的修改是u，撤销最近针对一行所做的全部修改是（　）
A、 f
B、 F
C、 U
D、 u
答案为: C

34、要在一个大文件中查找某个字符串，从光标处向后搜索与指定模式匹配的字符串是（　　）
A、 /
B、 ?
C、 #
D、 $
答案为: A

35、[root@localhost ~]# gcc -o hello1 hello.c和[root@localhost ~]# ./hello1表示的是（　　）
A、 编译、生成可执行文件hello1,并运行hello1
B、 编译、生成可执行文件hello1,并运行hello
C、 编译、生成可执行文件hello,并运行hello1
D、 编译、生成可执行文件hello,并运行hello
答案为: A

36、程序的顺序执行具有顺序性、封闭性和（    ）
A、 系统性
B、 程序性
C、 多分支性
D、 可再现性
答案为: D

37、程序的并发执行具有间断生、不可再现性和（    ）
A、 没有封闭性
B、 循环性	
C、 重复性
D、 可测试性
答案为: A

38、以下关于进程说法错误的是（    ）
A、 进程是一个可并发执行的程序在一个数据集上的一次运行
B、 进行就是程序的一次运行过程
C、 一个进程可以顺序执行多个程序
D、 一个程序不可以对应多个进程
答案为: C

39、进程已经分配到了除ＣＰＵ之外的所有资源，这时的时程状态称为（　　　）
A、 运行态	
B、 等待态
C、 就绪态
D、 控制态
答案为: C

40、可以使用（    ）查看记录进程ＰＣＢ中相关的信息
A、 ps
B、 pf 			
C、 pd
D、 pt
答案为: A

41、对单个进程中多条执行线索的支持，这些执行线索称为（　　　）
A、 程序
B、 线程
C、 进程
D、 软件
答案为: B

42、操作系统中用于管理内在空间的模块称为内存管理模块，它负责内存的全部管理工作，可以完成存储空间的分配、存储地址的变换、存储空间的保护和（    ）
A、 存储空间的扩充 		
B、 存储空间的删除
C、 存储地址的的扩充
D、 存储地址的删除
答案为: A

43、虚拟存储器的原理是用外存模拟内存，实现内存空间的扩充，程序的（    ）性使虚拟存储成为可能
A、 全局
B、 局部
C、 部份
D、 所有
答案为: B

44、Ext文件系统是专为Linux系统设计的一簇文件系统，以下是一个日志文件系统的是（    ）
A、 Ext2
B、 Ext3
C、 windows7
D、 windows
答案为: B

45、Ext文件的逻辑结构是无结构的流式文件，使得Linux系统可以（    ）
A、 把目录、设备当文件来处理
B、 把目录、设备当程序来处理
C、 把目录、设备当软件来处理
D、 把目录、设备当语言来处理
答案为: A

46、在Linux系统中，每个设备都对应一个设备文件，位于（    ）目录下
A、 /dev
B、 /tty
C、 /sda
D、 /loop
答案为: A

47、当网卡从网络上接收到流入的数据包时，此时CPU应该知道有数据包到了，CPU立即响应处理这个过程我们称为（ ）
A、 中断     
B、 调用
C、 测试
D、 应答
答案为: A

48、操作系统接口的功能就是提供一个用户使用系统的界面，根据服务对象的不同，操作系统的接口可以划分为两类，一是供用户使用的用户级接口中，二是（    ）
A、 设计接口
B、 程序级接口	
C、 交互级接口
D、 图形级接口
答案为: B

49、Linux系统的命令行接口是由Shell提供的方本方式的界面，也称为（    ）界面
A、 程序
B、 Ｘ
C、 Shell
D、 Bell
答案为: C

50、关于Shell语言错误的是（    ）
A、 Shell语言是一种解释性语言
B、 Shell语言是基于字符串的语言
C、 Shell语言是命令级语言
D、 Shell语言是要编译后才能执行的语言
答案为: D

51、通过按：alt+ctrl+F1或者alt+F1是提（    ）
A、 转换到虚拟终端 1（tty1）
B、 转换到虚拟终端 2（tty2）
C、 转换到虚拟终端 3（tty3）
D、 转换到虚拟终端 4（tty4）
答案为: A

52、获取工作站当前所有登陆者信息（    ）
A、 [root@localhost ~]# users
B、 [root@localhost ~]# user
C、 [root@localhost ~]# addusers
D、 [root@localhost ~]# ls
答案为: A

53、[ptname@localhost ~]$ find -atime -2是（    ）
A、 查找10小时数内修改过的文件
B、 查找12小时数内修改过的文件
C、 查找2小时数内修改过的文件
D、 查找48小时数内修改过的文件
答案为: D

54、[ptname@localhost~]$ find /var -name "*.log" 2> /dev/null是（）
A、 在目录/var查找以.2结尾的文件
B、 在目录/var查找以.log结尾的文件
C、 在目录/var查找以.name结尾的文件
D、 在目录/var查找以.varg结尾的文件
答案为: B

55、[ptname@localhost ~]$ find . -size +1000c –print是（　　）
A、 查找当前目录大于10K的文件
B、 查找当前目录大于100K的文件
C、 查找当前目录大于1000K的文件
D、 查找当前目录大于1K的文件
答案为: B

56、[ptname@localhost ~]$ tar cvf /tmp/backetc.tar /etc是（　）
A、 隐藏/etc 目录下的文件到/tmp目录下名为backetc
B、 修改/etc 目录下的文件到/tmp目录下名为backetc
C、 保存/etc 目录下的文件到/tmp目录下名为backetc
D、 删除/etc 目录下的文件到/tmp目录下名为backetc
答案为: C

57、[root@localhost ~]# ifconfig eth0表示的是（ ）
A、 配置eth0网卡
B、 显示eth0网卡相关信息
C、 测试eth0网卡通否
D、 关闭eth0多卡
答案为: B

58、[root@localhost ~]# ping 192.168.2.1表示的是
A、 测试与主机192.168.2.1的连通情况
B、 测试与主机192.168.2.1的主机名
C、 测试与主机192.168.2.1的DNS
D、 测试与主机192.168.2.1的邮件服务
答案为: A

59、Linux将磁盘分为IDE（即PATA）和SCSI（SCSI、SATA、USB）两大类。如果加载了U盘，以下可能显示正确的是（ ）
A、 hdb、hdc
B、 e：	
C、 sdb、sdc
D、 f：
答案为: C

60、[root@localhost ~]# mount -t auto -o ro /de/cdrom /media/cdrom
A、 把光驱加载到/media/cdrom目录下
B、 把光驱加载到/home目录下
C、 把U加载到/media/cdrom目录下
D、 把U加载到/home目录下
答案为: A

61、[root@localhost ~]# mount -o loop something.iso /mnt/iso是（ ）
A、 中止光盘映像文件something.iso加载
B、 删除光盘映像文件something.iso
C、 卸载光盘映像文件something.iso
D、 把光盘映像文件something.iso加载到/mnt/iso目录下
答案为: D

62、[root@localhost ~]# gzip -v *.c表示（ ）
A、 删除当前目录下的每个.c文件
B、 复制当前目录下的每个.c文件
C、 压缩当前目录下的每个.c文件
D、 解压当前目录下的每个.c文件
答案为: C

63、如有一个安装包名为foo-1.0-1.fc19.i686.rpm如果要安装此包的是（ ）
A、 [root@localhost ~]# rpm -ivh foo-1.0-1.fc19.i686.rpm
B、 [root@localhost ~]# add -ivh foo-1.0-1.fc19.i686.rpm
C、 [root@localhost ~]# aj -ivh foo-1.0-1.fc19.i686.rpm
D、 [root@localhost ~]# qa -ivh foo-1.0-1.fc19.i686.rpm
答案为: A

64、[root@localhost ~]# rpm -qa | grep gcc表示的是
A、 查询安装了哪些与gcc相关的软件包
B、 查询安装了哪些与rpm相关的软件包
C、 查询安装了哪些与grep相关的软件包
D、 查询安装了哪些与root相关的软件包
答案为: A

65、[ptname@localhost ~]$ alias cls=‘clear’ [ptname@localhost ~]$ alias [ptname@localhost ~]$ cls 所表示的是（    ）
A、 创建一个alias，可以使用cls的字符，执行系统能clear 命令
B、 创建一个alias，可以使用alias的字符，清除屏幕功能
C、 创建一个alias，可以使用cls 的字符，执行系统能alias命令
D、 以上都不对
答案为: A

66、Linux系统是面向各种应用环境的，有着多种运行模式，在不同的运行模式提供的系统功能也不同，系统通常工作在1-5级，2级支持多用启，3级支持网络网络，5级支持图形界面，服务器系统的默认启动级别是( )
A、 1
B、 2
C、 3
D、 4
答案为: C

67、[root@localhost ~]# shutdown10 "shutdown"表述正确的是（ ）
A、 所有登录用户的屏幕上都会出现root发出的关机"shutdown“提示信息
B、 10分钟后，所有登录用户的屏幕上都会出现root发出的关机"shutdown“提示信息
C、 直接关机
D、 10分钟后，关机后再开机
答案为: B

68、添加新用户zhoudake77，到2018年底终止的是（ ）
A、 [root@localhost ~]# useradd 2018-12-31 zhoudake77
B、 [root@localhost ~]# useradd 2018-12-31 zhoudake77
C、 [root@localhost ~]# useradd -g 2018-12-31 zhoudake77
D、 [root@localhost ~]# useradd -e 2018-12-31 zhoudake77
答案为: D

69、[root@localhost ~]# passwd -x10 zhoudake77表示的是（ ）
A、 设置zhoudake77口令的有效为10小时
B、 设置zhoudake77口令的有效为10天
C、 设置zhoudake77口令的有效为10个月
D、 以上都不对
答案为: B

70、删除用启zhoudake77,不保留其主目录和邮箱的是（ ）
A、 [root@localhost ~]# userdel -r zhoudake77
B、 [root@localhost ~]# userdel zhoudake77
C、 [root@localhost ~]# del -r zhoudake77
D、 [root@localhost ~]# del zhoudake77
答案为: B





Linux操作系统应用

以下描述正确的是？
选择一项：
a. Windows是批处理操作系统
b. 批处理系统可以同时执行多个任务
c. Linux就是批处理系统
d. 批处理系统出现早于分时系统
正确答案是：批处理系统出现早于分时系统

以下哪个是移动操作系统？
选择一项：
a. WindowsXP
b. Windows2003
c. Linux
d. Android
正确答案是：Android

Linux最早发布于哪一年？
选择一项：
a. 1990
b. 1991 
c. 1992
d. 1993
正确答案是：1991

第一个企业版的Linux是哪一个？
选择一项：
a. Debian
b. CentOS
c. RedHat 
d. Ubuntu
正确答案是：RedHat

以下哪个不是内核的组成部分？
选择一项：
a. 进程管理
b. 系统调用接口
c. C语言编译器 
d. 驱动程序
正确答案是：C语言编译器

Linux下常用文本编辑工具是？
选择一项：
a. EditPlus
b. DreamWeaver
c. VIM 
d. Notepad
正确答案是：VIM

Linux的终端软件英文名称是什么？
选择一项：
a. background
b. console
c.  terminal 
d. cmd
正确答案是： terminal

下载安装软件的命令是什么？
选择一项：
a.  setup
b. vim-version
c.  apt-getinstall 
d. sudo
正确答案是： apt-getinstall

以下哪些是Linux操作系统的特点？
选择一项或多项：
a. 低廉性 
b. 灵活性 
c. 网络性 
d. 广泛性
正确答案是：广泛性, 低廉性, 灵活性, 网络性

( )是计算机系统中最基本的软件，可直接管理和控制计算机的资源，合理地调度资源，使之得到充分的利用，并为用户使用这些资源提供一个方便的操作环境和良好的用户界面。
选择一项：
A. 操作系统 
B. 数据库
C. 办公软件
D. PS
正确答案是：操作系统

修改密码的命令是？
选择一项：
a. passwd 
b. password
c. update
d. change
正确答案是：passwd

进入某一文件夹的命令是？
选择一项：
a.  cd 
b.  help
c. ls
d.  ll
正确答案是： cd

列表显示所有文件的命令是？
选择一项：
a. cd
b. echo
c. ls 
d. pwd
正确答案是：ls

打印信息的命令是？
选择一项：
a. ls
b. pwd
c. echo 
d. ll
正确答案是：echo

列表显示文件详细信息的命令是？
选择一项：
a. cd
b.  ll 
c. help
d.  ls
正确答案是： ll

查找帮助的命令是？
选择一项：
a.  help 
b. echo
c. pwd
d. cd
正确答案是： help

查看系统当前运行所有程序的命令是？
选择一项：
a. ls
b. list
c. show
d. top
正确答案是：top

系统配置文件一般放在哪个目录下？
选择一项：
a. etc 
b.  tmp
c. dev
d. usr
正确答案是：etc

增加用户的命令是？
选择一项：
a. adduser 
b. appenduser
c. deluser
d.  insertuser
正确答案是：adduser

以下哪些描述是手机root后会产生的？
选择一项或多项：
a. 获取最高用户权限 
b. 可以任意安装软件 
c. 可以任意删除软件 
d. 增加系统风险
正确答案是：获取最高用户权限, 增加系统风险, 可以任意安装软件, 可以任意删除软件

使用哪个命令可以显示vi中的行号？
选择一项：
a.  :show
b.  :number
c.  :setnumber 
d.  :shownumber
正确答案是： :setnumber

在查找替换命令中，使用哪个符号来分隔要查找和替换的关键字？
选择一项：
a. / 
b.  ,
c.  |
d. \
正确答案是：/

保存并退出vi的命令是哪个？
选择一项：
a.  :wq 
b.  :q
c.  :q!
d. :w
正确答案是： :wq

vi应该在哪个模式下来输入文件内容？
选择一项：
a. 输入工作模式
b. 操作工作模式
c. 编辑工作模式 
d. 命令工作模式
正确答案是：编辑工作模式

从命令模式切换到编辑模式应该使用哪个命令？
选择一项：
a. i 
b. o
c. a
d. u
正确答案是：i

删除当前行应该使用哪个命令？
选择一项：
a. dl
b. dd 
c. dt
d. del
正确答案是：dd

撤消上一行操作应该使用哪个命令？
选择一项：
a. u 
b. o
c. a
d.  i
正确答案是：u

复制当前行使用哪个命令？
选择一项：
a. p
b. ps
c. cp
d.  yy
正确答案是： yy

粘贴应该使用哪个命令？
选择一项：
a. p 
b. yy
c. ps
d. cp
正确答案是：p

在命令模式移动光标可以使用哪些键？
选择一项或多项：
a. a
b. l 
c. k 
d. c
正确答案是：k, l

C语言头文件一般以什么名称结尾？
选择一项：
a. a
b. h 
c. so
d. c
正确答案是：h

C语言库文件一般以什么名称结尾？
选择一项：
a. so 
b. c
c. h
d. a
正确答案是：so

gcc在编译时，使用哪个参数来设置输出的文件名？
选择一项：
a. c
b. o 
c. e
d.  i
正确答案是：o

man命令查找Linux系统命令的用法应该使用哪个子命令？
选择一项：
a. １ 
b. ２
c. ４
d. ３
正确答案是：１

man命令查找C语言函数用法应该使用哪个子命令？
选择一项：
a. ４
b. １
c. ３ 
d. ２
正确答案是：３

使用gcc经过预编译后的文件一般以什么名称结尾？
选择一项：
a. u
b. a
c. i
d. o
正确答案是：o

进程在Linux中的表示是一个（）
选择一项：
a. 程序体
b. 封装体
c. 代码块
d. 结构体
正确答案是：结构体

以下哪些操作系统属于类Unix操作系统？
选择一项或多项：
a.  Windows
b. dos
c. BSD 
d.  Linux
正确答案是： Linux, BSD

进程通信的方式有（）
选择一项或多项：
a. 共享存储 
b. 管道 
c. 消息队列 
d. 套接字
正确答案是：管道, 消息队列, 套接字, 共享存储

下列选项属于线程的特点的是（）
选择一项或多项：
a. 不同线程可执行相同进程 
b. 有唯一标识 
c. 处理器独立调用 
d. 共享进程内存
正确答案是：有唯一标识, 不同线程可执行相同进程, 共享进程内存, 处理器独立调用

运行内核程序的运行模式被称作（）
选择一项：
a. 运行内核程序的运行模式被称作（）
b. 调试模式
c. 系统模式 
d. 用户模式
正确答案是：系统模式

进程的运行模式包含（）
选择一项或多项：
a. 调解模式
b. 调试模式
c. 用户模式 
d. 系统模式
正确答案是：用户模式, 系统模式

进程的控制块中包含（）
选择一项或多项：
a. 进程id 
b. 父进程id和所需资源 
c. 完成时间
d. 操作时间
正确答案是：进程id, 父进程id和所需资源

Linux的调度策略有（）
选择一项或多项：
a. 随机性策略
b. 优先级策略 
c. 根据进程对IO和处理器的请求多少对进程进行分类和时间片策略 
d. 倒序策略
正确答案是：优先级策略, 根据进程对IO和处理器的请求多少对进程进行分类和时间片策略

存储管理方案有（）
选择一项或多项：
a. 段式存储管理 
b. 分区存储管理 
c. 段页式存储管理 
d. 页式存储管理
正确答案是：分区存储管理, 页式存储管理, 段式存储管理, 段页式存储管理

存储管理方案有（）
选择一项或多项：
a. 页式存储管理 
b. 段页式存储管理 
c. 段式存储管理 
d. 分区存储管理
正确答案是：分区存储管理, 页式存储管理, 段式存储管理, 段页式存储管理

下列是引入线程的原因有（）
选择一项或多项：
a. 使任务保持开放性
b. 提高并发处理性能 
c. 进程操作耗时 
d. 使任务保持独立性
正确答案是：进程操作耗时, 提高并发处理性能

下面关于进程调度说法正确的是（）
选择一项或多项：
a. 决定进程运行的时间 
b. 是确保进程有效工作的内核子系统 
c. 多任务操作系统的基础 
d. 决定哪一个进程投入运行
正确答案是：是确保进程有效工作的内核子系统, 决定进程运行的时间, 多任务操作系统的基础, 决定哪一个进程投入运行

进程的状态包括（）
选择一项或多项：
a. 暂停状态
b. 运行状态和就绪状态 
c. 运行状态 
d. 暂运行状态
正确答案是：运行状态, 运行状态和就绪状态

可以使用（　　　　）查看记录进程ＰＣＢ中相关的信息
选择一项：
A. pf
B. ps 
C. pd
D. pt
正确答案是：ps





Linux操作系统安全与性能调优

企业信息安全框架不包含下面哪一项（）
选择一项：
a. 管理安全和运行安全
b. 数据安全
c.  物理安全
d. 硬件安全
正确答案是：硬件安全

以下哪一项属于采用面向内容的过滤技术（）
选择一项：
a. ＵＦＯ
b. ＤＶＰ
c. ＣＶＰ
d. ＵＦＰ
正确答案是：ＣＶＰ

数据安全是对信息在数据收集、处理、存储、检索、传输、交换、显示、扩散等过程中的保护。以下哪种不属于数据安全范畴（）。
选择一项：
a. 信息的机密性
b. 信息的完整性
c. 信息的可控性
d. 信息的不可否性
正确答案是：信息的可控性

采用认证、鉴别、PKI等技术，最主要是为了防范什么（）
选择一项：
a. 信息抵赖
b. 信息泄密
c. 信息破坏
d.  信息伪造
正确答案是： 信息伪造

机房管理、信息验证、加扰处理、电磁屏蔽和容错等措施，属于哪种安全（）
选择一项：
a. 运行安全
b. 管理安全
c. 物理安全
d. 数据安全
正确答案是：物理安全

VPN技术的含义是（）
选择一项：
a. 私有密码
b. 虚拟密码
c. 虚拟专用网络
d. 虚拟保护序列
正确答案是：虚拟专用网络

运行安全是指对网络与信息系统的运行过程和运行状态的保护。请选择相关符合的任务（）
选择一项或多项：
a.  信息验证
b. 实施防火墙
c. 建立硬件评估体系
d.  部署漏洞扫描
正确答案是： 部署漏洞扫描, 实施防火墙

内容安全主要涉及以下哪几个方面（）
选择一项或多项：
a. 信息的机密性
b. 信息的时效性
c. 信息的真实性
d. 信息的传播速度
正确答案是：信息的真实性, 信息的机密性

管理安全侧重以下哪几方面（）
选择一项或多项：
a. 安全制度，安全培训
b. 安装监控摄像
c. 增加人员
d. 权限分离
正确答案是：权限分离, 安全制度，安全培训

对Linux系统的安全设定包括哪几项（）
选择一项或多项：
a. 隐藏重要资料
b. 限制远程存取
c. 修补安全漏洞
d. 取消不必要的服务
正确答案是：取消不必要的服务, 限制远程存取, 隐藏重要资料, 修补安全漏洞
比对passwd和shadow是否一致（）
选择一项：
a. last
b. who
c. lastdb
d. pwck
正确答案是：pwck

在日志消息的8个级别中，“4WARNING”表示（）
选择一项：
a. 错误事件
b. 系统不可用
c. 调试信息
d. 警告事件
正确答案是：警告事件

在LINUX系统中，为了在一个可控制的范围内给普通用户jerry赋予管理员帐号如root的部分权限，最合适的方式是（）。
选择一项：
a. 将jerry用户的UID改为0
b. su
c. 将jerry用户加入到wheel组
d. sudo
正确答案是：sudo

针对admin组的用户配置sudo权限时，配置项第一列中需要使用（）形式表示
选择一项：
a. admin
b. :admin
c. ＠admin
d. ％admin
正确答案是：％admin

命令：[root@localhost~]#chage-d0zhangsan的含义是什么（）
选择一项：
a. zhangsan下次登陆需更改密码
b.  锁定zhangsan的密码
c. 取消zhangsan的密码
d. 禁用密码
正确答案是：zhangsan下次登陆需更改密码

在RHEL5系统的命令界面中，若设置环境变量（）的值为60，则当用户超过60秒没有任何操作时，将自动注销当前所在的命令终端。
选择一项：
a. TMOUT
b.  IDLE_TTL
c. TTL
d. TIMEOUT
正确答案是：TMOUT

以下哪个是内核及公共消息日志文件（）
选择一项：
a. /var/log/cron
b.  /var/log/dmesg
c. /var/log/messages
d. /var/log/maillog
正确答案是：/var/log/messages

/var/log/wtmp存储记录的哪一类日志（）
选择一项：
a. 当前登录的每个用户的详细信息
b. 用户登录、注销及系统开、关机事件
c. 最近的用户登录事件
d. 与用户验证相关的安全性事件
正确答案是：用户登录、注销及系统开、关机事件

用ac命令查看每个用户登录系统的时间,会列出当天一个个用户的时间总和的命令是哪一个（）。
选择一项：
a. ac-f
b. users
c. finger
d. ac-p
正确答案是：ac-p

进行系统账户清理时，以下哪几种方式可以考虑应用（）
选择一项或多项：
a. 锁定账号文件/etc/password
b. 锁定长期不使用的账号
c. 删除无用的账号
d.  将非登录用户的Shell设为/sbin/bash
正确答案是：锁定长期不使用的账号, 删除无用的账号
在通过调整BIOS引导设置来增强linux系统安全的措施中，以下哪些项是不必要的（）
选择一项：
a. 禁止从其他设备（光盘、U盘、网络）引导系统
b. 将安全级别设为setup，并设置管理员密码
c. 将第一引导设备设为当前系统所在硬盘
d. 将主板电池做跳线设置
正确答案是：将主板电池做跳线设置

在RedHat企业版5上，如何设置禁用重启热键Ctrl+Alt+Del（）
选择一项：
a. [root@localhost~]#vi/etc/inittab……#startoncontrol-alt-delete#exec/sbin/shutdown-rnow“Control-Alt-Deletepressed”
b.  [root@localhost~]#vi/etc/init/control-alt-delete.conf……#startoncontrol-alt-delete#exec/sbin/shutdown-rnow“Control-Alt-
c. [root@localhost~]#vi/etc/init/control-alt-delete.conf……#ca::ctrlaltdel:/sbin/shutdown-t3-rnow
d.  [root@localhost~]#vi/etc/inittab……#ca::ctrlaltdel:/sbin/shutdown-t3-rnow
正确答案是： [root@localhost~]#vi/etc/inittab……#ca::ctrlaltdel:/sbin/shutdown-t3-rnow

使用grub-md5-crypt命令的作用是（）
选择一项：
a. 获得加密字串
b. 检查密码安全性
c. 设置密码的机密度
d. 使用的是RSA算法生成字串
正确答案是：获得加密字串

限制root只在安全终端登录，修改哪个配置文件（）
选择一项：
a. /etc/securetty
b. /etc/grub
c. /etc/grub
d. /usr/etc/secure
正确答案是：/etc/securetty

修改系统登陆提示时，哪一项是显示本机登录提示（）
选择一项：
a. /etc/issue
b.  /etc/local/issue
c.  /etc/issue.net
d. /etc/network/issue.net
正确答案是：/etc/issue

管理员在grub.conf文件中的第一个“title……”行之前添加了密码设置，则在（）情况下需要提供密码。
选择一项：
a. 开机进入系统之前
b.  从图形模式切换到单用户模式
c. 开机时修改grub引导参数
d. 进入linux系统
正确答案是：开机时修改grub引导参数

减少开放终端个数，在企业版5中如何操作（）
选择一项：
a. [root@localhost~]#vi/etc/sysconfig/init……//省略部分内容ACTIVE_CONSOLES=/dev/tty[456]
b.  [root@localhost~]#vi/etc/inittab……#Rungettysinstandardrunlevels#1:2345:respawn:/sbin/mingettytty1#2:2345:respawn:/sbin/mingettytty2#3:2345:respawn:/sbin/mingettytty34:2345:respawn:/sbin/mingettytty45:2345:respawn:/sbin/mingettytty56:2345:respawn:/sbin/mingettytty6
c. #reboot
d.  [root@localhost~]#vi/etc/sysconfig/init#Rungettysinstandardrunlevels#1:2345:respawn:/sbin/mingettytty1#2:2345:respawn:/sbin/mingettytty2#3:2345:respawn:/sbin/mingettytty34:2345:respawn:/sbin/mingettytty45:2345:respawn:/sbin/mingettytty56:2345:respawn:/sbin/mingettytty6
正确答案是： [root@localhost~]#vi/etc/inittab……#Rungettysinstandardrunlevels#1:2345:respawn:/sbin/mingettytty1#2:2345:respawn:/sbin/mingettytty2#3:2345:respawn:/sbin/mingettytty34:2345:respawn:/sbin/mingettytty45:2345:respawn:/sbin/mingettytty56:2345:respawn:/sbin/mingettytty6

在重新启动Linux系统的同时把内存中的信息写入硬盘,应使用（）命令实现
选择一项：
a. #reboot
b.  #halt
c. #reboot
d. #shutdown–rnow
正确答案是：#shutdown–rnow

从后台启动进程,应在命令的结尾加上符号（）
选择一项：
a. $
b. @
c. #
d. &;
正确答案是：&;

构建基于密钥对验证的SSH服务时，服务器端默认的密钥库文件是（）
选择一项：
a. id.rsa
b. id_rsa.pub
c.  know_hosts
d.  authorized_keys
正确答案是： authorized_keys
在远程管理linux服务器时，以下（）方式采用加密的数据传输
选择一项：
a. rlogin
b.  rsh
c.  ssh
d. telnet
正确答案是： ssh

若需要禁止root用户以SSH方式登陆到服务器，可以在服务器上的sshd_config文件中作()设置。
选择一项：
a. AllowSuperLoginno
b. RootEnableno
c. DenyRootyes
d. PermitRootLoginno
正确答案是：PermitRootLoginno

在RHEL5系统环境中，通过密钥对验证方式加强SSH登录的安全时，应该将客户机生成的公钥文件内容添加到服务器端目标用户的（）文件中。
选择一项：
a. ~/.ssh/authorized_keys
b.  ~/.ssh/id_rsa
c. ~/.ssh/known_hosts
d. ~/.ssh/id_rsa.pub
正确答案是：~/.ssh/authorized_keys

在RHEL4系统中，使用ssh-keygen命令创建用户密钥对文件时，以下()是常用的加密算法
选择一项：
a. RSA
b. MD5
c. SHA
d. SSH1
正确答案是：RSA

在RHEL5系统中，设置TCPWrappers策略对vsftpd服务进行访问控制。若在/etc/hosts.allow文件中设置了“vsftpd:192.168.1.2”,在/etc/hosts.deny文件中设置了“vsftpd:192.168.1.2,192.168.1.3”,则以下说法正确的是()。
选择一项：
a. 只有IP为192.168.1.3主机允许访问该FTP服务器
b.  除了192.168.1.2和192.168.1.3以外的主机都允许访问该FTP服务器
c. 任何主机都不允许访问该FTP服务器
d. 除了192.168.1.3以外的主机都允许访问该FTP服务器
正确答案是：除了192.168.1.3以外的主机都允许访问该FTP服务器

使用makemenuconfig命令配置内核时，如果需要将一个功能编译为模块，应选择下面的状态（）。
选择一项：
a. [M]
b.  [#]
c.  [*]
d. []
正确答案是：[M]

在RHEL5系统中重新编译Linux内核，执行“makemenuconfig”步骤后保存的内核配置文件名默认为（）。
选择一项：
a. .config-2.6.28.8
b. kernel.cfg
c. makefile
d. .config
正确答案是：.config

LIDS的含义是（）
选择一项：
a. 本地入侵检测系统
b. Linux用户检测系统
c. Linux入侵检测系统
d. 网络入侵检测系统
正确答案是：Linux入侵检测系统

在RHEL5系统中，通过TCPWrappers机制加强对应用服务的访问控制时，使用的主要配置文件包括（）。
选择一项或多项：
a. /etc/hosts.allow
b. /etc/host.conf
c.  /etc/tcpd.conf
d. /etc/hosts.deny
正确答案是：/etc/hosts.allow, /etc/hosts.deny

如何找到一个影响服务器性能的问题，可以能过以下子系统进行分析（    ）
选择一项或多项：
A. CPU瓶颈
B. 网络瓶颈
C. 内存瓶颈
D. 磁盘瓶颈
正确答案是：CPU瓶颈, 内存瓶颈, 磁盘瓶颈, 网络瓶颈
在RHEL5系统中，为了在一个可控制的范围内给普通用户jerry赋予管理员帐号如root的部分权限，最合适的方式是（）。
选择一项：
a.  将jerry用户的UID改为0
b. sudo
c. su
d. 将jerry用户加入到wheel组
正确答案是：sudo

使用chattr命令的（）选项，可以将指定的文件设置为不可修改、不可删除、不可移动。
选择一项：
a. －a
b. －i
c. ＋a
d. ＋i
正确答案是：＋i

在/etc/fstab文件中指定的文件系统加载参数中,（）参数一般用于CD-ROM等移动设备
选择一项：
a. rw和ro
b. sw
c. defaults
d. noauto
正确答案是：noauto

下面关于i节点描述错误的是（）
选择一项：
a.  i节点能描述文件占用的块数
b. i节点和文件是一一对应的
c. 通过i节点实现文件的逻辑结构和物理结构的转换
d.  i节点描述了文件大小和指向数据块的指针
正确答案是：i节点和文件是一一对应的

下列关于/etc/fstab文件描述,正确的是（）
选择一项：
a.  CD_ROM和软盘必须是自动加载的
b.  fstab文件中描述的文件系统不能被卸载
c. fstab文件只能描述属于linux的文件系统
d. 启动时按fstab文件描述内容加载文件系统
正确答案是：启动时按fstab文件描述内容加载文件系统

对特殊权限粘滞位（stiky）的描述错误的是（）
选择一项：
a. set位和粘滞位的作用是一样的
b. 可用chmod命令设置
c. 设置粘滞位权限后，即便用户和对目录有写入权限，也不能删除该目录中其他用户的文件
d. sticky表示为文件其它用户执行权限位上的t或T
正确答案是：set位和粘滞位的作用是一样的

显示锁定文件的状态的命令是（）
选择一项：
a. lsattr+i
b.  lsattr-a
c. lsattr-
d. chattr–i
正确答案是： lsattr-a

使用加密文件系统（EFS）用到的命令是（）
选择一项或多项：
a. dmsetup
b. modprobedm-crypt
c. dmsetup
d. cryptsetup
正确答案是：cryptsetup, modprobedm-crypt

有关set位的描述，正确的是（）
选择一项或多项：
a. suid权限位的设定：chmodu+sFile...或chmod2nnnfilename...
b.  设置完set权限后，任何用户在执行此可执行文件的过程中，将获得该文件属主、属组的身份
c. sgid权限位的设定：chmodG+sFile...或chmod4nnnfilename...
d. set位权限有两部分组成：suid和sgid,分别对应可执行行文件属主和属组的身份
正确答案是： 设置完set权限后，任何用户在执行此可执行文件的过程中，将获得该文件属主、属组的身份, set位权限有两部分组成：suid和sgid,分别对应可执行行文件属主和属组的身份

以下不是CPU性能调整选项的是（）
选择一项：
A. 确认系统性能问题是CPU引起的，而不是其他子系统
B. 使用ps-ef命令来确认后台没有运行不必要的程序，使用cron来安排在非高峰时段运行
C. 在基于SMP的机器，尝试使用swap绑定进程到CPU,确保进程不会在处理器之间跳跃
D. 使用top识别非关键性CPU密集型程序，使用renice修改优先级
正确答案是：在基于SMP的机器，尝试使用swap绑定进程到CPU,确保进程不会在处理器之间跳跃
